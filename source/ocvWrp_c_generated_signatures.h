#ifdef __cplusplus
extern "C" {
#endif

struct Algorithm_t;

struct BFMatcher_t;

struct BOWImgDescriptorExtractor_t;

struct BOWKMeansTrainer_t;

struct BOWTrainer_t;

struct BRISK_t;

struct BackgroundSubtractor_t;

struct BackgroundSubtractorMOG_t;

struct BackgroundSubtractorMOG2_t;

struct CLAHE_t;

struct CascadeClassifier_t;

struct CvANN_MLP_t;

struct CvANN_MLP_TrainParams_t;

struct CvBoost_t;

struct CvBoostParams_t;

struct CvDTree_t;

struct CvDTreeParams_t;

struct CvERTrees_t;

struct CvGBTrees_t;

struct CvGBTreesParams_t;

struct CvKNearest_t;

struct CvNormalBayesClassifier_t;

struct CvParamGrid_t;

struct CvRTParams_t;

struct CvRTrees_t;

struct CvSVM_t;

struct CvSVMParams_t;

struct CvStatModel_t;

struct DMatch_t;

struct DescriptorExtractor_t;

struct DescriptorMatcher_t;

struct EM_t;

struct FaceRecognizer_t;

struct FastFeatureDetector_t;

struct Feature2D_t;

struct FeatureDetector_t;

struct FileNode_t;

struct FileStorage_t;

struct FlannBasedMatcher_t;

struct GFTTDetector_t;

struct GridAdaptedFeatureDetector_t;

struct HOGDescriptor_t;

struct KDTree_t;

struct KalmanFilter_t;

struct KeyPoint_t;

struct MSER_t;

struct ORB_t;

struct PyramidAdaptedFeatureDetector_t;

struct SIFT_t;

struct SURF_t;

struct SimpleBlobDetector_t;

struct SimpleBlobDetector_Params_t;

struct StarDetector_t;

struct StereoBM_t;

struct StereoSGBM_t;

struct StereoVar_t;

struct Subdiv2D_t;

struct VideoCapture_t;

struct VideoWriter_t;

struct flann_Index_t;
struct  BFMatcher_t*      pCvBFMatcherCreate(int normType /* default: NORM_L2 */, bool crossCheck /* default: false */);
void                      pCvBFMatcherDelete(struct BFMatcher_t* wrapper);
struct  BOWImgDescriptorExtractor_t*  pCvBOWImgDescriptorExtractorCreate(Ptr_DescriptorExtractor* dextractor, Ptr_DescriptorMatcher* dmatcher);
void                      pCvBOWImgDescriptorExtractorDelete(struct BOWImgDescriptorExtractor_t* wrapper);
struct  BOWKMeansTrainer_t*  pCvBOWKMeansTrainerCreate(int clusterCount, TermCriteria_t* termcrit /* default: TermCriteria() */, int attempts /* default: 3 */, int flags /* default: KMEANS_PP_CENTERS */);
void                      pCvBOWKMeansTrainerDelete(struct BOWKMeansTrainer_t* wrapper);
struct  BRISK_t*          pCvBRISKCreate(int thresh /* default: 30 */, int octaves /* default: 3 */, float patternScale /* default: 1.0f */);
struct  BRISK_t*          pCvBRISKCreate2(vector_float* radiusList, vector_int* numberList, float dMax /* default: 5.85f */, float dMin /* default: 8.2f */, vector_int* indexChange /* default: std::vector<int>() */);
void                      pCvBRISKDelete(struct BRISK_t* wrapper);
struct  BackgroundSubtractorMOG_t*  pCvBackgroundSubtractorMOGCreate();
struct  BackgroundSubtractorMOG_t*  pCvBackgroundSubtractorMOGCreate2(int history, int nmixtures, double backgroundRatio, double noiseSigma /* default: 0 */);
void                      pCvBackgroundSubtractorMOGDelete(struct BackgroundSubtractorMOG_t* wrapper);
struct  BackgroundSubtractorMOG2_t*  pCvBackgroundSubtractorMOG2Create();
struct  BackgroundSubtractorMOG2_t*  pCvBackgroundSubtractorMOG2Create2(int history, float varThreshold, bool bShadowDetection /* default: true */);
void                      pCvBackgroundSubtractorMOG2Delete(struct BackgroundSubtractorMOG2_t* wrapper);
struct  CascadeClassifier_t*  pCvCascadeClassifierCreate();
struct  CascadeClassifier_t*  pCvCascadeClassifierCreate2(string_t* filename);
void                      pCvCascadeClassifierDelete(struct CascadeClassifier_t* wrapper);
struct  CvANN_MLP_t*      pCvCvANN_MLPCreate();
struct  CvANN_MLP_t*      pCvCvANN_MLPCreate2(Mat_t* layerSizes, int activateFunc /* default: CvANN_MLP::SIGMOID_SYM */, double fparam1 /* default: 0 */, double fparam2 /* default: 0 */);
void                      pCvCvANN_MLPDelete(struct CvANN_MLP_t* wrapper);
struct  CvBoost_t*        pCvCvBoostCreate();
struct  CvBoost_t*        pCvCvBoostCreate2(Mat_t* trainData, int tflag, Mat_t* responses, Mat_t* varIdx /* default: cv::Mat() */, Mat_t* sampleIdx /* default: cv::Mat() */, Mat_t* varType /* default: cv::Mat() */, Mat_t* missingDataMask /* default: cv::Mat() */, CvBoostParams_t* params /* default: CvBoostParams() */);
void                      pCvCvBoostDelete(struct CvBoost_t* wrapper);
struct  CvDTree_t*        pCvCvDTreeCreate();
void                      pCvCvDTreeDelete(struct CvDTree_t* wrapper);
struct  CvERTrees_t*      pCvCvERTreesCreate();
void                      pCvCvERTreesDelete(struct CvERTrees_t* wrapper);
struct  CvGBTrees_t*      pCvCvGBTreesCreate();
struct  CvGBTrees_t*      pCvCvGBTreesCreate2(Mat_t* trainData, int tflag, Mat_t* responses, Mat_t* varIdx /* default: cv::Mat() */, Mat_t* sampleIdx /* default: cv::Mat() */, Mat_t* varType /* default: cv::Mat() */, Mat_t* missingDataMask /* default: cv::Mat() */, CvGBTreesParams_t* params /* default: CvGBTreesParams() */);
void                      pCvCvGBTreesDelete(struct CvGBTrees_t* wrapper);
struct  CvKNearest_t*     pCvCvKNearestCreate();
struct  CvKNearest_t*     pCvCvKNearestCreate2(Mat_t* trainData, Mat_t* responses, Mat_t* sampleIdx /* default: cv::Mat() */, bool isRegression /* default: false */, int max_k /* default: 32 */);
void                      pCvCvKNearestDelete(struct CvKNearest_t* wrapper);
struct  CvNormalBayesClassifier_t*  pCvCvNormalBayesClassifierCreate();
struct  CvNormalBayesClassifier_t*  pCvCvNormalBayesClassifierCreate2(Mat_t* trainData, Mat_t* responses, Mat_t* varIdx /* default: cv::Mat() */, Mat_t* sampleIdx /* default: cv::Mat() */);
void                      pCvCvNormalBayesClassifierDelete(struct CvNormalBayesClassifier_t* wrapper);
struct  CvRTrees_t*       pCvCvRTreesCreate();
void                      pCvCvRTreesDelete(struct CvRTrees_t* wrapper);
struct  CvSVM_t*          pCvCvSVMCreate();
struct  CvSVM_t*          pCvCvSVMCreate2(Mat_t* trainData, Mat_t* responses, Mat_t* varIdx /* default: cv::Mat() */, Mat_t* sampleIdx /* default: cv::Mat() */, CvSVMParams_t* params /* default: CvSVMParams() */);
void                      pCvCvSVMDelete(struct CvSVM_t* wrapper);
struct  DMatch_t*         pCvDMatchCreate();
struct  DMatch_t*         pCvDMatchCreate2(int _queryIdx, int _trainIdx, float _distance);
struct  DMatch_t*         pCvDMatchCreate3(int _queryIdx, int _trainIdx, int _imgIdx, float _distance);
void                      pCvDMatchDelete(struct DMatch_t* wrapper);
struct  EM_t*             pCvEMCreate(int nclusters /* default: EM::DEFAULT_NCLUSTERS */, int covMatType /* default: EM::COV_MAT_DIAGONAL */, TermCriteria_t* termCrit /* default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, EM::DEFAULT_MAX_ITERS, FLT_EPSILON) */);
void                      pCvEMDelete(struct EM_t* wrapper);
struct  FastFeatureDetector_t*  pCvFastFeatureDetectorCreate(int threshold /* default: 10 */, bool nonmaxSuppression /* default: true */);
void                      pCvFastFeatureDetectorDelete(struct FastFeatureDetector_t* wrapper);
struct  FileNode_t*       pCvFileNodeCreate();
void                      pCvFileNodeDelete(struct FileNode_t* wrapper);
struct  FileStorage_t*    pCvFileStorageCreate();
struct  FileStorage_t*    pCvFileStorageCreate2(string_t* source, int flags, string_t* encoding /* default: string() */);
void                      pCvFileStorageDelete(struct FileStorage_t* wrapper);
struct  FlannBasedMatcher_t*  pCvFlannBasedMatcherCreate(Ptr_flann_IndexParams* indexParams /* default: new flann::KDTreeIndexParams() */, Ptr_flann_SearchParams* searchParams /* default: new flann::SearchParams() */);
void                      pCvFlannBasedMatcherDelete(struct FlannBasedMatcher_t* wrapper);
struct  GFTTDetector_t*   pCvGFTTDetectorCreate(int maxCorners /* default: 1000 */, double qualityLevel /* default: 0.01 */, double minDistance /* default: 1 */, int blockSize /* default: 3 */, bool useHarrisDetector /* default: false */, double k /* default: 0.04 */);
void                      pCvGFTTDetectorDelete(struct GFTTDetector_t* wrapper);
struct  GridAdaptedFeatureDetector_t*  pCvGridAdaptedFeatureDetectorCreate(Ptr_FeatureDetector* detector /* default: 0 */, int maxTotalKeypoints /* default: 1000 */, int gridRows /* default: 4 */, int gridCols /* default: 4 */);
void                      pCvGridAdaptedFeatureDetectorDelete(struct GridAdaptedFeatureDetector_t* wrapper);
struct  HOGDescriptor_t*  pCvHOGDescriptorCreate();
struct  HOGDescriptor_t*  pCvHOGDescriptorCreate2(Size_t* _winSize, Size_t* _blockSize, Size_t* _blockStride, Size_t* _cellSize, int _nbins, int _derivAperture /* default: 1 */, double _winSigma /* default: -1 */, int _histogramNormType /* default: HOGDescriptor::L2Hys */, double _L2HysThreshold /* default: 0.2 */, bool _gammaCorrection /* default: false */, int _nlevels /* default: HOGDescriptor::DEFAULT_NLEVELS */);
struct  HOGDescriptor_t*  pCvHOGDescriptorCreate3(string_t* filename);
void                      pCvHOGDescriptorDelete(struct HOGDescriptor_t* wrapper);
struct  flann_Index_t*    pCvflann_IndexCreate();
struct  flann_Index_t*    pCvflann_IndexCreate2(Mat_t* features, IndexParams_t* params, cvflann_flann_distance_t distType /* default: cvflann::FLANN_DIST_L2 */);
void                      pCvflann_IndexDelete(struct flann_Index_t* wrapper);
struct  KDTree_t*         pCvKDTreeCreate();
struct  KDTree_t*         pCvKDTreeCreate2(Mat_t* points, bool copyAndReorderPoints /* default: false */);
struct  KDTree_t*         pCvKDTreeCreate3(Mat_t* points, Mat_t* _labels, bool copyAndReorderPoints /* default: false */);
void                      pCvKDTreeDelete(struct KDTree_t* wrapper);
struct  KalmanFilter_t*   pCvKalmanFilterCreate();
struct  KalmanFilter_t*   pCvKalmanFilterCreate2(int dynamParams, int measureParams, int controlParams /* default: 0 */, int _type /* default: CV_32F */);
void                      pCvKalmanFilterDelete(struct KalmanFilter_t* wrapper);
struct  KeyPoint_t*       pCvKeyPointCreate();
struct  KeyPoint_t*       pCvKeyPointCreate2(float x, float y, float _size, float _angle /* default: -1 */, float _response /* default: 0 */, int _octave /* default: 0 */, int _class_id /* default: -1 */);
void                      pCvKeyPointDelete(struct KeyPoint_t* wrapper);
struct  MSER_t*           pCvMSERCreate(int _delta /* default: 5 */, int _min_area /* default: 60 */, int _max_area /* default: 14400 */, double _max_variation /* default: 0.25 */, double _min_diversity /* default: .2 */, int _max_evolution /* default: 200 */, double _area_threshold /* default: 1.01 */, double _min_margin /* default: 0.003 */, int _edge_blur_size /* default: 5 */);
void                      pCvMSERDelete(struct MSER_t* wrapper);
struct  ORB_t*            pCvORBCreate(int nfeatures /* default: 500 */, float scaleFactor /* default: 1.2f */, int nlevels /* default: 8 */, int edgeThreshold /* default: 31 */, int firstLevel /* default: 0 */, int WTA_K /* default: 2 */, int scoreType /* default: ORB::HARRIS_SCORE */, int patchSize /* default: 31 */);
void                      pCvORBDelete(struct ORB_t* wrapper);
struct  SimpleBlobDetector_Params_t*  pCvSimpleBlobDetector_ParamsCreate();
void                      pCvSimpleBlobDetector_ParamsDelete(struct SimpleBlobDetector_Params_t* wrapper);
struct  PyramidAdaptedFeatureDetector_t*  pCvPyramidAdaptedFeatureDetectorCreate(Ptr_FeatureDetector* detector, int maxLevel /* default: 2 */);
void                      pCvPyramidAdaptedFeatureDetectorDelete(struct PyramidAdaptedFeatureDetector_t* wrapper);
struct  SIFT_t*           pCvSIFTCreate(int nfeatures /* default: 0 */, int nOctaveLayers /* default: 3 */, double contrastThreshold /* default: 0.04 */, double edgeThreshold /* default: 10 */, double sigma /* default: 1.6 */);
void                      pCvSIFTDelete(struct SIFT_t* wrapper);
struct  SURF_t*           pCvSURFCreate();
struct  SURF_t*           pCvSURFCreate2(double hessianThreshold, int nOctaves /* default: 4 */, int nOctaveLayers /* default: 2 */, bool extended /* default: true */, bool upright /* default: false */);
void                      pCvSURFDelete(struct SURF_t* wrapper);
struct  SimpleBlobDetector_t*  pCvSimpleBlobDetectorCreate(SimpleBlobDetector_Params_t* parameters /* default: SimpleBlobDetector::Params() */);
void                      pCvSimpleBlobDetectorDelete(struct SimpleBlobDetector_t* wrapper);
struct  StarDetector_t*   pCvStarDetectorCreate(int _maxSize /* default: 45 */, int _responseThreshold /* default: 30 */, int _lineThresholdProjected /* default: 10 */, int _lineThresholdBinarized /* default: 8 */, int _suppressNonmaxSize /* default: 5 */);
void                      pCvStarDetectorDelete(struct StarDetector_t* wrapper);
struct  StereoBM_t*       pCvStereoBMCreate();
struct  StereoBM_t*       pCvStereoBMCreate2(int preset, int ndisparities /* default: 0 */, int SADWindowSize /* default: 21 */);
void                      pCvStereoBMDelete(struct StereoBM_t* wrapper);
struct  StereoSGBM_t*     pCvStereoSGBMCreate();
struct  StereoSGBM_t*     pCvStereoSGBMCreate2(int minDisparity, int numDisparities, int SADWindowSize, int P1 /* default: 0 */, int P2 /* default: 0 */, int disp12MaxDiff /* default: 0 */, int preFilterCap /* default: 0 */, int uniquenessRatio /* default: 0 */, int speckleWindowSize /* default: 0 */, int speckleRange /* default: 0 */, bool fullDP /* default: false */);
void                      pCvStereoSGBMDelete(struct StereoSGBM_t* wrapper);
struct  StereoVar_t*      pCvStereoVarCreate();
struct  StereoVar_t*      pCvStereoVarCreate2(int levels, double pyrScale, int nIt, int minDisp, int maxDisp, int poly_n, double poly_sigma, float fi, float lambda, int penalization, int cycle, int flags);
void                      pCvStereoVarDelete(struct StereoVar_t* wrapper);
struct  Subdiv2D_t*       pCvSubdiv2DCreate();
struct  Subdiv2D_t*       pCvSubdiv2DCreate2(Rect_t* rect);
void                      pCvSubdiv2DDelete(struct Subdiv2D_t* wrapper);
struct  VideoCapture_t*   pCvVideoCaptureCreate();
struct  VideoCapture_t*   pCvVideoCaptureCreate2(string_t* filename);
struct  VideoCapture_t*   pCvVideoCaptureCreate3(int device);
void                      pCvVideoCaptureDelete(struct VideoCapture_t* wrapper);
struct  VideoWriter_t*    pCvVideoWriterCreate();
struct  VideoWriter_t*    pCvVideoWriterCreate2(string_t* filename, int fourcc, double fps, Size_t* frameSize, bool isColor /* default: true */);
void                      pCvVideoWriterDelete(struct VideoWriter_t* wrapper);
Ptr_Algorithm*            pCvAlgorithmgetAlgorithm(struct  Algorithm_t* wrapper, string_t* name);
bool                      pCvAlgorithmgetBool(struct  Algorithm_t* wrapper, string_t* name);
double                    pCvAlgorithmgetDouble(struct  Algorithm_t* wrapper, string_t* name);
int                       pCvAlgorithmgetInt(struct  Algorithm_t* wrapper, string_t* name);
Mat_t*                    pCvAlgorithmgetMat(struct  Algorithm_t* wrapper, string_t* name);
vector_Mat*               pCvAlgorithmgetMatVector(struct  Algorithm_t* wrapper, string_t* name);
void                      pCvAlgorithmgetParams(struct  Algorithm_t* wrapper, vector_string* names);
string_t*                 pCvAlgorithmgetString(struct  Algorithm_t* wrapper, string_t* name);
string_t*                 pCvAlgorithmparamHelp(struct  Algorithm_t* wrapper, string_t* name);
int                       pCvAlgorithmparamType(struct  Algorithm_t* wrapper, string_t* name);
void                      pCvAlgorithmsetAlgorithm(struct  Algorithm_t* wrapper, string_t* name, Ptr_Algorithm* value);
void                      pCvAlgorithmsetBool(struct  Algorithm_t* wrapper, string_t* name, bool value);
void                      pCvAlgorithmsetDouble(struct  Algorithm_t* wrapper, string_t* name, double value);
void                      pCvAlgorithmsetInt(struct  Algorithm_t* wrapper, string_t* name, int value);
void                      pCvAlgorithmsetMat(struct  Algorithm_t* wrapper, string_t* name, Mat_t* value);
void                      pCvAlgorithmsetMatVector(struct  Algorithm_t* wrapper, string_t* name, vector_Mat* value);
void                      pCvAlgorithmsetString(struct  Algorithm_t* wrapper, string_t* name, string_t* value);
void                      pCvBFMatcheradd(struct  BFMatcher_t* wrapper, vector_Mat* descriptors);
void                      pCvBFMatcherclear(struct  BFMatcher_t* wrapper);
bool                      pCvBFMatcherempty(struct  BFMatcher_t* wrapper);
vector_Mat*               pCvBFMatchergetTrainDescriptors(struct  BFMatcher_t* wrapper);
void                      pCvBFMatcherknnMatch(struct  BFMatcher_t* wrapper, Mat_t* queryDescriptors, Mat_t* trainDescriptors, vector_vector_DMatch* matches, int k, Mat_t* mask /* default: Mat() */, bool compactResult /* default: false */);
void                      pCvBFMatcherknnMatch2(struct  BFMatcher_t* wrapper, Mat_t* queryDescriptors, vector_vector_DMatch* matches, int k, vector_Mat* masks /* default: vector<Mat>() */, bool compactResult /* default: false */);
void                      pCvBFMatchermatch(struct  BFMatcher_t* wrapper, Mat_t* queryDescriptors, Mat_t* trainDescriptors, vector_DMatch* matches, Mat_t* mask /* default: Mat() */);
void                      pCvBFMatchermatch2(struct  BFMatcher_t* wrapper, Mat_t* queryDescriptors, vector_DMatch* matches, vector_Mat* masks /* default: vector<Mat>() */);
void                      pCvBFMatchertrain(struct  BFMatcher_t* wrapper);
void                      pCvBOWImgDescriptorExtractorcompute(struct  BOWImgDescriptorExtractor_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* imgDescriptor);
int                       pCvBOWImgDescriptorExtractordescriptorSize(struct  BOWImgDescriptorExtractor_t* wrapper);
int                       pCvBOWImgDescriptorExtractordescriptorType(struct  BOWImgDescriptorExtractor_t* wrapper);
Mat_t*                    pCvBOWImgDescriptorExtractorgetVocabulary(struct  BOWImgDescriptorExtractor_t* wrapper);
void                      pCvBOWImgDescriptorExtractorsetVocabulary(struct  BOWImgDescriptorExtractor_t* wrapper, Mat_t* vocabulary);
void                      pCvBOWKMeansTraineradd(struct  BOWKMeansTrainer_t* wrapper, Mat_t* descriptors);
void                      pCvBOWKMeansTrainerclear(struct  BOWKMeansTrainer_t* wrapper);
Mat_t*                    pCvBOWKMeansTrainercluster(struct  BOWKMeansTrainer_t* wrapper);
Mat_t*                    pCvBOWKMeansTrainercluster2(struct  BOWKMeansTrainer_t* wrapper, Mat_t* descriptors);
int                       pCvBOWKMeansTrainerdescripotorsCount(struct  BOWKMeansTrainer_t* wrapper);
vector_Mat*               pCvBOWKMeansTrainergetDescriptors(struct  BOWKMeansTrainer_t* wrapper);
void                      pCvBOWTraineradd(struct  BOWTrainer_t* wrapper, Mat_t* descriptors);
void                      pCvBOWTrainerclear(struct  BOWTrainer_t* wrapper);
int                       pCvBOWTrainerdescripotorsCount(struct  BOWTrainer_t* wrapper);
vector_Mat*               pCvBOWTrainergetDescriptors(struct  BOWTrainer_t* wrapper);
void                      pCvBRISKcompute(struct  BRISK_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* descriptors);
void                      pCvBRISKdetectAndCompute(struct  BRISK_t* wrapper, Mat_t* image, Mat_t* mask, vector_KeyPoint* keypoints, Mat_t* descriptors, bool useProvidedKeypoints /* default: false */);
void                      pCvBRISKgenerateKernel(struct  BRISK_t* wrapper, vector_float* radiusList, vector_int* numberList, float dMax /* default: 5.85f */, float dMin /* default: 8.2f */, vector_int* indexChange /* default: std::vector<int>() */);
void                      pCvBackgroundSubtractorapply(struct  BackgroundSubtractor_t* wrapper, Mat_t* image, Mat_t* fgmask, double learningRate /* default: 0 */);
void                      pCvBackgroundSubtractorMOGapply(struct  BackgroundSubtractorMOG_t* wrapper, Mat_t* image, Mat_t* fgmask, double learningRate /* default: 0 */);
void                      pCvBackgroundSubtractorMOG2apply(struct  BackgroundSubtractorMOG2_t* wrapper, Mat_t* image, Mat_t* fgmask, double learningRate /* default: 0 */);
void                      pCvCLAHEapply(struct  CLAHE_t* wrapper, Mat_t* src, Mat_t* dst);
void                      pCvCLAHEsetClipLimit(struct  CLAHE_t* wrapper, double clipLimit);
void                      pCvCLAHEsetTilesGridSize(struct  CLAHE_t* wrapper, Size_t* tileGridSize);
void                      pCvCascadeClassifierdetectMultiScale(struct  CascadeClassifier_t* wrapper, Mat_t* image, vector_Rect* objects, double scaleFactor /* default: 1.1 */, int minNeighbors /* default: 3 */, int flags /* default: 0 */, Size_t* minSize /* default: Size() */, Size_t* maxSize /* default: Size() */);
void                      pCvCascadeClassifierdetectMultiScale2(struct  CascadeClassifier_t* wrapper, Mat_t* image, vector_Rect* objects, vector_int* rejectLevels, vector_double* levelWeights, double scaleFactor /* default: 1.1 */, int minNeighbors /* default: 3 */, int flags /* default: 0 */, Size_t* minSize /* default: Size() */, Size_t* maxSize /* default: Size() */, bool outputRejectLevels /* default: false */);
bool                      pCvCascadeClassifierempty(struct  CascadeClassifier_t* wrapper);
bool                      pCvCascadeClassifierload(struct  CascadeClassifier_t* wrapper, string_t* filename);
void                      pCvCvANN_MLPclear(struct  CvANN_MLP_t* wrapper);
void                      pCvCvANN_MLP_create(struct  CvANN_MLP_t* wrapper, Mat_t* layerSizes, int activateFunc /* default: CvANN_MLP::SIGMOID_SYM */, double fparam1 /* default: 0 */, double fparam2 /* default: 0 */);
void                      pCvCvANN_MLPload(struct  CvANN_MLP_t* wrapper, c_string filename, c_string name /* default: 0 */);
float                     pCvCvANN_MLPpredict(struct  CvANN_MLP_t* wrapper, Mat_t* inputs, Mat_t* outputs);
void                      pCvCvANN_MLPsave(struct  CvANN_MLP_t* wrapper, c_string filename, c_string name /* default: 0 */);
int                       pCvCvANN_MLPtrain(struct  CvANN_MLP_t* wrapper, Mat_t* inputs, Mat_t* outputs, Mat_t* sampleWeights, Mat_t* sampleIdx /* default: cv::Mat() */, CvANN_MLP_TrainParams_t* params /* default: CvANN_MLP_TrainParams() */, int flags /* default: 0 */);
double                       pCvCvANN_MLP_TrainParamsGet_bp_dw_scale(CvANN_MLP_TrainParams_t* p);
void                      pCvCvANN_MLP_TrainParamsSet_bp_dw_scale(CvANN_MLP_TrainParams_t* p, double val);
double                       pCvCvANN_MLP_TrainParamsGet_bp_moment_scale(CvANN_MLP_TrainParams_t* p);
void                      pCvCvANN_MLP_TrainParamsSet_bp_moment_scale(CvANN_MLP_TrainParams_t* p, double val);
double                       pCvCvANN_MLP_TrainParamsGet_rp_dw0(CvANN_MLP_TrainParams_t* p);
void                      pCvCvANN_MLP_TrainParamsSet_rp_dw0(CvANN_MLP_TrainParams_t* p, double val);
double                       pCvCvANN_MLP_TrainParamsGet_rp_dw_max(CvANN_MLP_TrainParams_t* p);
void                      pCvCvANN_MLP_TrainParamsSet_rp_dw_max(CvANN_MLP_TrainParams_t* p, double val);
double                       pCvCvANN_MLP_TrainParamsGet_rp_dw_min(CvANN_MLP_TrainParams_t* p);
void                      pCvCvANN_MLP_TrainParamsSet_rp_dw_min(CvANN_MLP_TrainParams_t* p, double val);
double                       pCvCvANN_MLP_TrainParamsGet_rp_dw_minus(CvANN_MLP_TrainParams_t* p);
void                      pCvCvANN_MLP_TrainParamsSet_rp_dw_minus(CvANN_MLP_TrainParams_t* p, double val);
double                       pCvCvANN_MLP_TrainParamsGet_rp_dw_plus(CvANN_MLP_TrainParams_t* p);
void                      pCvCvANN_MLP_TrainParamsSet_rp_dw_plus(CvANN_MLP_TrainParams_t* p, double val);
CvTermCriteria_t*                       pCvCvANN_MLP_TrainParamsGet_term_crit(CvANN_MLP_TrainParams_t* p);
void                      pCvCvANN_MLP_TrainParamsSet_term_crit(CvANN_MLP_TrainParams_t* p, CvTermCriteria_t* val);
int                       pCvCvANN_MLP_TrainParamsGet_train_method(CvANN_MLP_TrainParams_t* p);
void                      pCvCvANN_MLP_TrainParamsSet_train_method(CvANN_MLP_TrainParams_t* p, int val);
void                      pCvCvBoostclear(struct  CvBoost_t* wrapper);
void                      pCvCvBoostload(struct  CvBoost_t* wrapper, c_string filename, c_string name /* default: 0 */);
float                     pCvCvBoostpredict(struct  CvBoost_t* wrapper, Mat_t* sample, Mat_t* missing /* default: cv::Mat() */, Range_t* slice /* default: cv::Range::all() */, bool rawMode /* default: false */, bool returnSum /* default: false */);
void                      pCvCvBoostprune(struct  CvBoost_t* wrapper, CvSlice_t* slice);
void                      pCvCvBoostsave(struct  CvBoost_t* wrapper, c_string filename, c_string name /* default: 0 */);
bool                      pCvCvBoosttrain(struct  CvBoost_t* wrapper, Mat_t* trainData, int tflag, Mat_t* responses, Mat_t* varIdx /* default: cv::Mat() */, Mat_t* sampleIdx /* default: cv::Mat() */, Mat_t* varType /* default: cv::Mat() */, Mat_t* missingDataMask /* default: cv::Mat() */, CvBoostParams_t* params /* default: CvBoostParams() */, bool update /* default: false */);
int                       pCvCvBoostParamsGet_boost_type(CvBoostParams_t* p);
void                      pCvCvBoostParamsSet_boost_type(CvBoostParams_t* p, int val);
int                       pCvCvBoostParamsGet_split_criteria(CvBoostParams_t* p);
void                      pCvCvBoostParamsSet_split_criteria(CvBoostParams_t* p, int val);
int                       pCvCvBoostParamsGet_weak_count(CvBoostParams_t* p);
void                      pCvCvBoostParamsSet_weak_count(CvBoostParams_t* p, int val);
double                       pCvCvBoostParamsGet_weight_trim_rate(CvBoostParams_t* p);
void                      pCvCvBoostParamsSet_weight_trim_rate(CvBoostParams_t* p, double val);
void                      pCvCvDTreeclear(struct  CvDTree_t* wrapper);
Mat_t*                    pCvCvDTreegetVarImportance(struct  CvDTree_t* wrapper);
void                      pCvCvDTreeload(struct  CvDTree_t* wrapper, c_string filename, c_string name /* default: 0 */);
CvDTreeNode_t*            pCvCvDTreepredict(struct  CvDTree_t* wrapper, Mat_t* sample, Mat_t* missingDataMask /* default: cv::Mat() */, bool preprocessedInput /* default: false */);
void                      pCvCvDTreesave(struct  CvDTree_t* wrapper, c_string filename, c_string name /* default: 0 */);
bool                      pCvCvDTreetrain(struct  CvDTree_t* wrapper, Mat_t* trainData, int tflag, Mat_t* responses, Mat_t* varIdx /* default: cv::Mat() */, Mat_t* sampleIdx /* default: cv::Mat() */, Mat_t* varType /* default: cv::Mat() */, Mat_t* missingDataMask /* default: cv::Mat() */, CvDTreeParams_t* params /* default: CvDTreeParams() */);
int                       pCvCvDTreeParamsGet_cv_folds(CvDTreeParams_t* p);
void                      pCvCvDTreeParamsSet_cv_folds(CvDTreeParams_t* p, int val);
int                       pCvCvDTreeParamsGet_max_categories(CvDTreeParams_t* p);
void                      pCvCvDTreeParamsSet_max_categories(CvDTreeParams_t* p, int val);
int                       pCvCvDTreeParamsGet_max_depth(CvDTreeParams_t* p);
void                      pCvCvDTreeParamsSet_max_depth(CvDTreeParams_t* p, int val);
int                       pCvCvDTreeParamsGet_min_sample_count(CvDTreeParams_t* p);
void                      pCvCvDTreeParamsSet_min_sample_count(CvDTreeParams_t* p, int val);
float                       pCvCvDTreeParamsGet_regression_accuracy(CvDTreeParams_t* p);
void                      pCvCvDTreeParamsSet_regression_accuracy(CvDTreeParams_t* p, float val);
bool                       pCvCvDTreeParamsGet_truncate_pruned_tree(CvDTreeParams_t* p);
void                      pCvCvDTreeParamsSet_truncate_pruned_tree(CvDTreeParams_t* p, bool val);
bool                       pCvCvDTreeParamsGet_use_1se_rule(CvDTreeParams_t* p);
void                      pCvCvDTreeParamsSet_use_1se_rule(CvDTreeParams_t* p, bool val);
bool                       pCvCvDTreeParamsGet_use_surrogates(CvDTreeParams_t* p);
void                      pCvCvDTreeParamsSet_use_surrogates(CvDTreeParams_t* p, bool val);
void                      pCvCvERTreesclear(struct  CvERTrees_t* wrapper);
Mat_t*                    pCvCvERTreesgetVarImportance(struct  CvERTrees_t* wrapper);
float                     pCvCvERTreespredict(struct  CvERTrees_t* wrapper, Mat_t* sample, Mat_t* missing /* default: cv::Mat() */);
float                     pCvCvERTreespredict_prob(struct  CvERTrees_t* wrapper, Mat_t* sample, Mat_t* missing /* default: cv::Mat() */);
bool                      pCvCvERTreestrain(struct  CvERTrees_t* wrapper, Mat_t* trainData, int tflag, Mat_t* responses, Mat_t* varIdx /* default: cv::Mat() */, Mat_t* sampleIdx /* default: cv::Mat() */, Mat_t* varType /* default: cv::Mat() */, Mat_t* missingDataMask /* default: cv::Mat() */, CvRTParams_t* params /* default: CvRTParams() */);
void                      pCvCvGBTreesclear(struct  CvGBTrees_t* wrapper);
void                      pCvCvGBTreesload(struct  CvGBTrees_t* wrapper, c_string filename, c_string name /* default: 0 */);
float                     pCvCvGBTreespredict(struct  CvGBTrees_t* wrapper, Mat_t* sample, Mat_t* missing /* default: cv::Mat() */, Range_t* slice /* default: cv::Range::all() */, int k /* default: -1 */);
void                      pCvCvGBTreessave(struct  CvGBTrees_t* wrapper, c_string filename, c_string name /* default: 0 */);
bool                      pCvCvGBTreestrain(struct  CvGBTrees_t* wrapper, Mat_t* trainData, int tflag, Mat_t* responses, Mat_t* varIdx /* default: cv::Mat() */, Mat_t* sampleIdx /* default: cv::Mat() */, Mat_t* varType /* default: cv::Mat() */, Mat_t* missingDataMask /* default: cv::Mat() */, CvGBTreesParams_t* params /* default: CvGBTreesParams() */, bool update /* default: false */);
int                       pCvCvGBTreesParamsGet_loss_function_type(CvGBTreesParams_t* p);
void                      pCvCvGBTreesParamsSet_loss_function_type(CvGBTreesParams_t* p, int val);
float                       pCvCvGBTreesParamsGet_shrinkage(CvGBTreesParams_t* p);
void                      pCvCvGBTreesParamsSet_shrinkage(CvGBTreesParams_t* p, float val);
float                       pCvCvGBTreesParamsGet_subsample_portion(CvGBTreesParams_t* p);
void                      pCvCvGBTreesParamsSet_subsample_portion(CvGBTreesParams_t* p, float val);
int                       pCvCvGBTreesParamsGet_weak_count(CvGBTreesParams_t* p);
void                      pCvCvGBTreesParamsSet_weak_count(CvGBTreesParams_t* p, int val);
float                     pCvCvKNearestfind_nearest(struct  CvKNearest_t* wrapper, Mat_t* samples, int k, Mat_t* results, Mat_t* neighborResponses, Mat_t* dists);
void                      pCvCvKNearestload(struct  CvKNearest_t* wrapper, c_string filename, c_string name /* default: 0 */);
void                      pCvCvKNearestsave(struct  CvKNearest_t* wrapper, c_string filename, c_string name /* default: 0 */);
bool                      pCvCvKNearesttrain(struct  CvKNearest_t* wrapper, Mat_t* trainData, Mat_t* responses, Mat_t* sampleIdx /* default: cv::Mat() */, bool isRegression /* default: false */, int maxK /* default: 32 */, bool updateBase /* default: false */);
void                      pCvCvNormalBayesClassifierclear(struct  CvNormalBayesClassifier_t* wrapper);
void                      pCvCvNormalBayesClassifierload(struct  CvNormalBayesClassifier_t* wrapper, c_string filename, c_string name /* default: 0 */);
float                     pCvCvNormalBayesClassifierpredict(struct  CvNormalBayesClassifier_t* wrapper, Mat_t* samples, Mat_t* results /* default: 0 */);
void                      pCvCvNormalBayesClassifiersave(struct  CvNormalBayesClassifier_t* wrapper, c_string filename, c_string name /* default: 0 */);
bool                      pCvCvNormalBayesClassifiertrain(struct  CvNormalBayesClassifier_t* wrapper, Mat_t* trainData, Mat_t* responses, Mat_t* varIdx /* default: cv::Mat() */, Mat_t* sampleIdx /* default: cv::Mat() */, bool update /* default: false */);
double                       pCvCvParamGridGet_max_val(CvParamGrid_t* p);
void                      pCvCvParamGridSet_max_val(CvParamGrid_t* p, double val);
double                       pCvCvParamGridGet_min_val(CvParamGrid_t* p);
void                      pCvCvParamGridSet_min_val(CvParamGrid_t* p, double val);
double                       pCvCvParamGridGet_step(CvParamGrid_t* p);
void                      pCvCvParamGridSet_step(CvParamGrid_t* p, double val);
bool                       pCvCvRTParamsGet_calc_var_importance(CvRTParams_t* p);
void                      pCvCvRTParamsSet_calc_var_importance(CvRTParams_t* p, bool val);
int                       pCvCvRTParamsGet_nactive_vars(CvRTParams_t* p);
void                      pCvCvRTParamsSet_nactive_vars(CvRTParams_t* p, int val);
CvTermCriteria_t*                       pCvCvRTParamsGet_term_crit(CvRTParams_t* p);
void                      pCvCvRTParamsSet_term_crit(CvRTParams_t* p, CvTermCriteria_t* val);
void                      pCvCvRTreesclear(struct  CvRTrees_t* wrapper);
Mat_t*                    pCvCvRTreesgetVarImportance(struct  CvRTrees_t* wrapper);
void                      pCvCvRTreesload(struct  CvRTrees_t* wrapper, c_string filename, c_string name /* default: 0 */);
float                     pCvCvRTreespredict(struct  CvRTrees_t* wrapper, Mat_t* sample, Mat_t* missing /* default: cv::Mat() */);
float                     pCvCvRTreespredict_prob(struct  CvRTrees_t* wrapper, Mat_t* sample, Mat_t* missing /* default: cv::Mat() */);
void                      pCvCvRTreessave(struct  CvRTrees_t* wrapper, c_string filename, c_string name /* default: 0 */);
bool                      pCvCvRTreestrain(struct  CvRTrees_t* wrapper, Mat_t* trainData, int tflag, Mat_t* responses, Mat_t* varIdx /* default: cv::Mat() */, Mat_t* sampleIdx /* default: cv::Mat() */, Mat_t* varType /* default: cv::Mat() */, Mat_t* missingDataMask /* default: cv::Mat() */, CvRTParams_t* params /* default: CvRTParams() */);
void                      pCvCvSVMclear(struct  CvSVM_t* wrapper);
int                       pCvCvSVMget_support_vector_count(struct  CvSVM_t* wrapper);
int                       pCvCvSVMget_var_count(struct  CvSVM_t* wrapper);
void                      pCvCvSVMload(struct  CvSVM_t* wrapper, c_string filename, c_string name /* default: 0 */);
float                     pCvCvSVMpredict(struct  CvSVM_t* wrapper, Mat_t* sample, bool returnDFVal /* default: false */);
void                      pCvCvSVMpredict_all(struct  CvSVM_t* wrapper, Mat_t* samples, Mat_t* results);
void                      pCvCvSVMsave(struct  CvSVM_t* wrapper, c_string filename, c_string name /* default: 0 */);
bool                      pCvCvSVMtrain(struct  CvSVM_t* wrapper, Mat_t* trainData, Mat_t* responses, Mat_t* varIdx /* default: cv::Mat() */, Mat_t* sampleIdx /* default: cv::Mat() */, CvSVMParams_t* params /* default: CvSVMParams() */);
bool                      pCvCvSVMtrain_auto(struct  CvSVM_t* wrapper, Mat_t* trainData, Mat_t* responses, Mat_t* varIdx, Mat_t* sampleIdx, CvSVMParams_t* params, int k_fold /* default: 10 */, CvParamGrid_t* Cgrid /* default: CvSVM::get_default_grid(CvSVM::C) */, CvParamGrid_t* gammaGrid /* default: CvSVM::get_default_grid(CvSVM::GAMMA) */, CvParamGrid_t* pGrid /* default: CvSVM::get_default_grid(CvSVM::P) */, CvParamGrid_t* nuGrid /* default: CvSVM::get_default_grid(CvSVM::NU) */, CvParamGrid_t* coeffGrid /* default: CvSVM::get_default_grid(CvSVM::COEF) */, CvParamGrid_t* degreeGrid /* default: CvSVM::get_default_grid(CvSVM::DEGREE) */, bool balanced /* default: false */);
double                       pCvCvSVMParamsGet_C(CvSVMParams_t* p);
void                      pCvCvSVMParamsSet_C(CvSVMParams_t* p, double val);
double                       pCvCvSVMParamsGet_coef0(CvSVMParams_t* p);
void                      pCvCvSVMParamsSet_coef0(CvSVMParams_t* p, double val);
double                       pCvCvSVMParamsGet_degree(CvSVMParams_t* p);
void                      pCvCvSVMParamsSet_degree(CvSVMParams_t* p, double val);
double                       pCvCvSVMParamsGet_gamma(CvSVMParams_t* p);
void                      pCvCvSVMParamsSet_gamma(CvSVMParams_t* p, double val);
int                       pCvCvSVMParamsGet_kernel_type(CvSVMParams_t* p);
void                      pCvCvSVMParamsSet_kernel_type(CvSVMParams_t* p, int val);
double                       pCvCvSVMParamsGet_nu(CvSVMParams_t* p);
void                      pCvCvSVMParamsSet_nu(CvSVMParams_t* p, double val);
double                       pCvCvSVMParamsGet_p(CvSVMParams_t* p);
void                      pCvCvSVMParamsSet_p(CvSVMParams_t* p, double val);
int                       pCvCvSVMParamsGet_svm_type(CvSVMParams_t* p);
void                      pCvCvSVMParamsSet_svm_type(CvSVMParams_t* p, int val);
CvTermCriteria_t*                       pCvCvSVMParamsGet_term_crit(CvSVMParams_t* p);
void                      pCvCvSVMParamsSet_term_crit(CvSVMParams_t* p, CvTermCriteria_t* val);
void                      pCvCvStatModelload(struct  CvStatModel_t* wrapper, c_string filename, c_string name /* default: 0 */);
void                      pCvCvStatModelsave(struct  CvStatModel_t* wrapper, c_string filename, c_string name /* default: 0 */);
float                       pCvDMatchGet_distance(DMatch_t* p);
void                      pCvDMatchSet_distance(DMatch_t* p, float val);
int                       pCvDMatchGet_imgIdx(DMatch_t* p);
void                      pCvDMatchSet_imgIdx(DMatch_t* p, int val);
int                       pCvDMatchGet_queryIdx(DMatch_t* p);
void                      pCvDMatchSet_queryIdx(DMatch_t* p, int val);
int                       pCvDMatchGet_trainIdx(DMatch_t* p);
void                      pCvDMatchSet_trainIdx(DMatch_t* p, int val);
void                      pCvDescriptorExtractorcompute(struct  DescriptorExtractor_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* descriptors);
bool                      pCvDescriptorExtractorempty(struct  DescriptorExtractor_t* wrapper);
void                      pCvDescriptorMatcheradd(struct  DescriptorMatcher_t* wrapper, vector_Mat* descriptors);
void                      pCvDescriptorMatcherclear(struct  DescriptorMatcher_t* wrapper);
bool                      pCvDescriptorMatcherempty(struct  DescriptorMatcher_t* wrapper);
vector_Mat*               pCvDescriptorMatchergetTrainDescriptors(struct  DescriptorMatcher_t* wrapper);
void                      pCvDescriptorMatcherknnMatch(struct  DescriptorMatcher_t* wrapper, Mat_t* queryDescriptors, Mat_t* trainDescriptors, vector_vector_DMatch* matches, int k, Mat_t* mask /* default: Mat() */, bool compactResult /* default: false */);
void                      pCvDescriptorMatcherknnMatch2(struct  DescriptorMatcher_t* wrapper, Mat_t* queryDescriptors, vector_vector_DMatch* matches, int k, vector_Mat* masks /* default: vector<Mat>() */, bool compactResult /* default: false */);
void                      pCvDescriptorMatchermatch(struct  DescriptorMatcher_t* wrapper, Mat_t* queryDescriptors, Mat_t* trainDescriptors, vector_DMatch* matches, Mat_t* mask /* default: Mat() */);
void                      pCvDescriptorMatchermatch2(struct  DescriptorMatcher_t* wrapper, Mat_t* queryDescriptors, vector_DMatch* matches, vector_Mat* masks /* default: vector<Mat>() */);
void                      pCvDescriptorMatchertrain(struct  DescriptorMatcher_t* wrapper);
void                      pCvEMclear(struct  EM_t* wrapper);
bool                      pCvEMisTrained(struct  EM_t* wrapper);
Vec2d_t*                  pCvEMpredict(struct  EM_t* wrapper, Mat_t* sample, Mat_t* probs /* default: Mat() */);
bool                      pCvEMtrain(struct  EM_t* wrapper, Mat_t* samples, Mat_t* logLikelihoods /* default: Mat() */, Mat_t* labels /* default: Mat() */, Mat_t* probs /* default: Mat() */);
bool                      pCvEMtrainE(struct  EM_t* wrapper, Mat_t* samples, Mat_t* means0, Mat_t* covs0 /* default: Mat() */, Mat_t* weights0 /* default: Mat() */, Mat_t* logLikelihoods /* default: Mat() */, Mat_t* labels /* default: Mat() */, Mat_t* probs /* default: Mat() */);
bool                      pCvEMtrainM(struct  EM_t* wrapper, Mat_t* samples, Mat_t* probs0, Mat_t* logLikelihoods /* default: Mat() */, Mat_t* labels /* default: Mat() */, Mat_t* probs /* default: Mat() */);
void                      pCvFaceRecognizerload(struct  FaceRecognizer_t* wrapper, string_t* filename);
void                      pCvFaceRecognizerpredict(struct  FaceRecognizer_t* wrapper, Mat_t* src, int _label, double confidence);
void                      pCvFaceRecognizersave(struct  FaceRecognizer_t* wrapper, string_t* filename);
void                      pCvFaceRecognizertrain(struct  FaceRecognizer_t* wrapper, vector_Mat* src, Mat_t* labels);
void                      pCvFaceRecognizerupdate(struct  FaceRecognizer_t* wrapper, vector_Mat* src, Mat_t* labels);
void                      pCvFastFeatureDetectordetect(struct  FastFeatureDetector_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
void                      pCvFeature2Dcompute(struct  Feature2D_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* descriptors);
void                      pCvFeature2Ddetect(struct  Feature2D_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
void                      pCvFeature2DdetectAndCompute(struct  Feature2D_t* wrapper, Mat_t* image, Mat_t* mask, vector_KeyPoint* keypoints, Mat_t* descriptors, bool useProvidedKeypoints /* default: false */);
void                      pCvFeatureDetectordetect(struct  FeatureDetector_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
bool                      pCvFeatureDetectorempty(struct  FeatureDetector_t* wrapper);
bool                      pCvFileNodeempty(struct  FileNode_t* wrapper);
bool                      pCvFileNodeisInt(struct  FileNode_t* wrapper);
bool                      pCvFileNodeisMap(struct  FileNode_t* wrapper);
bool                      pCvFileNodeisNamed(struct  FileNode_t* wrapper);
bool                      pCvFileNodeisNone(struct  FileNode_t* wrapper);
bool                      pCvFileNodeisReal(struct  FileNode_t* wrapper);
bool                      pCvFileNodeisSeq(struct  FileNode_t* wrapper);
bool                      pCvFileNodeisString(struct  FileNode_t* wrapper);
string_t*                 pCvFileNodename(struct  FileNode_t* wrapper);
FileNode_t*               pCvFileNodegetelem(struct  FileNode_t* wrapper, c_string nodename);
FileNode_t*               pCvFileNodegetelem2(struct  FileNode_t* wrapper, int i);
size_t                    pCvFileNodesize(struct  FileNode_t* wrapper);
int                       pCvFileNodetype(struct  FileNode_t* wrapper);
FileNode_t*               pCvFileStoragegetFirstTopLevelNode(struct  FileStorage_t* wrapper);
bool                      pCvFileStorageisOpened(struct  FileStorage_t* wrapper);
bool                      pCvFileStorageopen(struct  FileStorage_t* wrapper, string_t* filename, int flags, string_t* encoding /* default: string() */);
FileNode_t*               pCvFileStoragegetelem(struct  FileStorage_t* wrapper, c_string nodename);
void                      pCvFileStoragerelease(struct  FileStorage_t* wrapper);
string_t*                 pCvFileStoragereleaseAndGetString(struct  FileStorage_t* wrapper);
FileNode_t*               pCvFileStorageroot(struct  FileStorage_t* wrapper, int streamidx /* default: 0 */);
void                      pCvFlannBasedMatcheradd(struct  FlannBasedMatcher_t* wrapper, vector_Mat* descriptors);
void                      pCvFlannBasedMatcherclear(struct  FlannBasedMatcher_t* wrapper);
bool                      pCvFlannBasedMatcherempty(struct  FlannBasedMatcher_t* wrapper);
vector_Mat*               pCvFlannBasedMatchergetTrainDescriptors(struct  FlannBasedMatcher_t* wrapper);
void                      pCvFlannBasedMatcherknnMatch(struct  FlannBasedMatcher_t* wrapper, Mat_t* queryDescriptors, Mat_t* trainDescriptors, vector_vector_DMatch* matches, int k, Mat_t* mask /* default: Mat() */, bool compactResult /* default: false */);
void                      pCvFlannBasedMatcherknnMatch2(struct  FlannBasedMatcher_t* wrapper, Mat_t* queryDescriptors, vector_vector_DMatch* matches, int k, vector_Mat* masks /* default: vector<Mat>() */, bool compactResult /* default: false */);
void                      pCvFlannBasedMatchermatch(struct  FlannBasedMatcher_t* wrapper, Mat_t* queryDescriptors, Mat_t* trainDescriptors, vector_DMatch* matches, Mat_t* mask /* default: Mat() */);
void                      pCvFlannBasedMatchermatch2(struct  FlannBasedMatcher_t* wrapper, Mat_t* queryDescriptors, vector_DMatch* matches, vector_Mat* masks /* default: vector<Mat>() */);
void                      pCvFlannBasedMatchertrain(struct  FlannBasedMatcher_t* wrapper);
void                      pCvGFTTDetectordetect(struct  GFTTDetector_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
void                      pCvGridAdaptedFeatureDetectordetect(struct  GridAdaptedFeatureDetector_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
bool                      pCvHOGDescriptorcheckDetectorSize(struct  HOGDescriptor_t* wrapper);
void                      pCvHOGDescriptorcompute(struct  HOGDescriptor_t* wrapper, Mat_t* img, vector_float* descriptors, Size_t* winStride /* default: Size() */, Size_t* padding /* default: Size() */, vector_Point* locations /* default: vector<Point>() */);
void                      pCvHOGDescriptorcomputeGradient(struct  HOGDescriptor_t* wrapper, Mat_t* img, Mat_t* grad, Mat_t* angleOfs, Size_t* paddingTL /* default: Size() */, Size_t* paddingBR /* default: Size() */);
void                      pCvHOGDescriptordetect(struct  HOGDescriptor_t* wrapper, Mat_t* img, vector_Point* foundLocations, vector_double* weights, double hitThreshold /* default: 0 */, Size_t* winStride /* default: Size() */, Size_t* padding /* default: Size() */, vector_Point* searchLocations /* default: vector<Point>() */);
void                      pCvHOGDescriptordetectMultiScale(struct  HOGDescriptor_t* wrapper, Mat_t* img, vector_Rect* foundLocations, vector_double* foundWeights, double hitThreshold /* default: 0 */, Size_t* winStride /* default: Size() */, Size_t* padding /* default: Size() */, double scale /* default: 1.05 */, double finalThreshold /* default: 2.0 */, bool useMeanshiftGrouping /* default: false */);
size_t                    pCvHOGDescriptorgetDescriptorSize(struct  HOGDescriptor_t* wrapper);
double                    pCvHOGDescriptorgetWinSigma(struct  HOGDescriptor_t* wrapper);
bool                      pCvHOGDescriptorload(struct  HOGDescriptor_t* wrapper, string_t* filename, string_t* objname /* default: String() */);
void                      pCvHOGDescriptorsave(struct  HOGDescriptor_t* wrapper, string_t* filename, string_t* objname /* default: String() */);
void                      pCvHOGDescriptorsetSVMDetector(struct  HOGDescriptor_t* wrapper, Mat_t* _svmdetector);
double                       pCvHOGDescriptorGet_L2HysThreshold(HOGDescriptor_t* p);
Size_t*                       pCvHOGDescriptorGet_blockSize(HOGDescriptor_t* p);
Size_t*                       pCvHOGDescriptorGet_blockStride(HOGDescriptor_t* p);
Size_t*                       pCvHOGDescriptorGet_cellSize(HOGDescriptor_t* p);
int                       pCvHOGDescriptorGet_derivAperture(HOGDescriptor_t* p);
bool                       pCvHOGDescriptorGet_gammaCorrection(HOGDescriptor_t* p);
int                       pCvHOGDescriptorGet_histogramNormType(HOGDescriptor_t* p);
int                       pCvHOGDescriptorGet_nbins(HOGDescriptor_t* p);
int                       pCvHOGDescriptorGet_nlevels(HOGDescriptor_t* p);
vector_float*                       pCvHOGDescriptorGet_svmDetector(HOGDescriptor_t* p);
double                       pCvHOGDescriptorGet_winSigma(HOGDescriptor_t* p);
Size_t*                       pCvHOGDescriptorGet_winSize(HOGDescriptor_t* p);
void                      pCvKDTreebuild(struct  KDTree_t* wrapper, Mat_t* points, bool copyAndReorderPoints /* default: false */);
void                      pCvKDTreebuild2(struct  KDTree_t* wrapper, Mat_t* points, Mat_t* labels, bool copyAndReorderPoints /* default: false */);
int                       pCvKDTreedims(struct  KDTree_t* wrapper);
int                       pCvKDTreefindNearest(struct  KDTree_t* wrapper, Mat_t* vec, int K, int Emax, Mat_t* neighborsIdx, Mat_t* neighbors /* default: Mat() */, Mat_t* dist /* default: Mat() */, Mat_t* labels /* default: Mat() */);
void                      pCvKDTreefindOrthoRange(struct  KDTree_t* wrapper, Mat_t* minBounds, Mat_t* maxBounds, Mat_t* neighborsIdx, Mat_t* neighbors /* default: Mat() */, Mat_t* labels /* default: Mat() */);
void                      pCvKDTreegetPoints(struct  KDTree_t* wrapper, Mat_t* idx, Mat_t* pts, Mat_t* labels /* default: Mat() */);
vector_int*                       pCvKDTreeGet_labels(KDTree_t* p);
int                       pCvKDTreeGet_maxDepth(KDTree_t* p);
int                       pCvKDTreeGet_normType(KDTree_t* p);
void                      pCvKDTreeSet_normType(KDTree_t* p, int val);
Mat_t*                       pCvKDTreeGet_points(KDTree_t* p);
Mat_t*                    pCvKalmanFiltercorrect(struct  KalmanFilter_t* wrapper, Mat_t* measurement);
Mat_t*                    pCvKalmanFilterpredict(struct  KalmanFilter_t* wrapper, Mat_t* control /* default: Mat() */);
float                       pCvKeyPointGet_angle(KeyPoint_t* p);
void                      pCvKeyPointSet_angle(KeyPoint_t* p, float val);
int                       pCvKeyPointGet_class_id(KeyPoint_t* p);
void                      pCvKeyPointSet_class_id(KeyPoint_t* p, int val);
int                       pCvKeyPointGet_octave(KeyPoint_t* p);
void                      pCvKeyPointSet_octave(KeyPoint_t* p, int val);
Point2f_t*                       pCvKeyPointGet_pt(KeyPoint_t* p);
void                      pCvKeyPointSet_pt(KeyPoint_t* p, Point2f_t* val);
float                       pCvKeyPointGet_response(KeyPoint_t* p);
void                      pCvKeyPointSet_response(KeyPoint_t* p, float val);
float                       pCvKeyPointGet_size(KeyPoint_t* p);
void                      pCvKeyPointSet_size(KeyPoint_t* p, float val);
void                      pCvMSERdetect(struct  MSER_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
void                      pCvORBcompute(struct  ORB_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* descriptors);
void                      pCvORBdetect(struct  ORB_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
void                      pCvORBdetectAndCompute(struct  ORB_t* wrapper, Mat_t* image, Mat_t* mask, vector_KeyPoint* keypoints, Mat_t* descriptors, bool useProvidedKeypoints /* default: false */);
void                      pCvPyramidAdaptedFeatureDetectordetect(struct  PyramidAdaptedFeatureDetector_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
void                      pCvSIFTcompute(struct  SIFT_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* descriptors);
int                       pCvSIFTdescriptorSize(struct  SIFT_t* wrapper);
int                       pCvSIFTdescriptorType(struct  SIFT_t* wrapper);
void                      pCvSIFTdetect(struct  SIFT_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
void                      pCvSIFTdetectAndCompute(struct  SIFT_t* wrapper, Mat_t* image, Mat_t* mask, vector_KeyPoint* keypoints, Mat_t* descriptors, bool useProvidedKeypoints /* default: false */);
void                      pCvSURFcompute(struct  SURF_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* descriptors);
int                       pCvSURFdescriptorSize(struct  SURF_t* wrapper);
int                       pCvSURFdescriptorType(struct  SURF_t* wrapper);
void                      pCvSURFdetect(struct  SURF_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
void                      pCvSURFdetectAndCompute(struct  SURF_t* wrapper, Mat_t* image, Mat_t* mask, vector_KeyPoint* keypoints, Mat_t* descriptors, bool useProvidedKeypoints /* default: false */);
bool                       pCvSURFGet_extended(SURF_t* p);
void                      pCvSURFSet_extended(SURF_t* p, bool val);
double                       pCvSURFGet_hessianThreshold(SURF_t* p);
void                      pCvSURFSet_hessianThreshold(SURF_t* p, double val);
int                       pCvSURFGet_nOctaveLayers(SURF_t* p);
void                      pCvSURFSet_nOctaveLayers(SURF_t* p, int val);
int                       pCvSURFGet_nOctaves(SURF_t* p);
void                      pCvSURFSet_nOctaves(SURF_t* p, int val);
bool                       pCvSURFGet_upright(SURF_t* p);
void                      pCvSURFSet_upright(SURF_t* p, bool val);
void                      pCvSimpleBlobDetectordetect(struct  SimpleBlobDetector_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
uchar                       pCvSimpleBlobDetector_ParamsGet_blobColor(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_blobColor(SimpleBlobDetector_Params_t* p, uchar val);
bool                       pCvSimpleBlobDetector_ParamsGet_filterByArea(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_filterByArea(SimpleBlobDetector_Params_t* p, bool val);
bool                       pCvSimpleBlobDetector_ParamsGet_filterByCircularity(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_filterByCircularity(SimpleBlobDetector_Params_t* p, bool val);
bool                       pCvSimpleBlobDetector_ParamsGet_filterByColor(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_filterByColor(SimpleBlobDetector_Params_t* p, bool val);
bool                       pCvSimpleBlobDetector_ParamsGet_filterByConvexity(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_filterByConvexity(SimpleBlobDetector_Params_t* p, bool val);
bool                       pCvSimpleBlobDetector_ParamsGet_filterByInertia(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_filterByInertia(SimpleBlobDetector_Params_t* p, bool val);
float                       pCvSimpleBlobDetector_ParamsGet_maxArea(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_maxArea(SimpleBlobDetector_Params_t* p, float val);
float                       pCvSimpleBlobDetector_ParamsGet_maxCircularity(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_maxCircularity(SimpleBlobDetector_Params_t* p, float val);
float                       pCvSimpleBlobDetector_ParamsGet_maxConvexity(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_maxConvexity(SimpleBlobDetector_Params_t* p, float val);
float                       pCvSimpleBlobDetector_ParamsGet_maxInertiaRatio(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_maxInertiaRatio(SimpleBlobDetector_Params_t* p, float val);
float                       pCvSimpleBlobDetector_ParamsGet_maxThreshold(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_maxThreshold(SimpleBlobDetector_Params_t* p, float val);
float                       pCvSimpleBlobDetector_ParamsGet_minArea(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_minArea(SimpleBlobDetector_Params_t* p, float val);
float                       pCvSimpleBlobDetector_ParamsGet_minCircularity(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_minCircularity(SimpleBlobDetector_Params_t* p, float val);
float                       pCvSimpleBlobDetector_ParamsGet_minConvexity(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_minConvexity(SimpleBlobDetector_Params_t* p, float val);
float                       pCvSimpleBlobDetector_ParamsGet_minDistBetweenBlobs(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_minDistBetweenBlobs(SimpleBlobDetector_Params_t* p, float val);
float                       pCvSimpleBlobDetector_ParamsGet_minInertiaRatio(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_minInertiaRatio(SimpleBlobDetector_Params_t* p, float val);
size_t                       pCvSimpleBlobDetector_ParamsGet_minRepeatability(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_minRepeatability(SimpleBlobDetector_Params_t* p, size_t val);
float                       pCvSimpleBlobDetector_ParamsGet_minThreshold(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_minThreshold(SimpleBlobDetector_Params_t* p, float val);
float                       pCvSimpleBlobDetector_ParamsGet_thresholdStep(SimpleBlobDetector_Params_t* p);
void                      pCvSimpleBlobDetector_ParamsSet_thresholdStep(SimpleBlobDetector_Params_t* p, float val);
void                      pCvStarDetectordetect(struct  StarDetector_t* wrapper, Mat_t* image, vector_KeyPoint* keypoints, Mat_t* mask /* default: Mat() */);
void                      pCvStereoBMcompute(struct  StereoBM_t* wrapper, Mat_t* left, Mat_t* right, Mat_t* disparity, int disptype /* default: CV_16S */);
void                      pCvStereoSGBMcompute(struct  StereoSGBM_t* wrapper, Mat_t* left, Mat_t* right, Mat_t* disp);
int                       pCvStereoSGBMGet_P1(StereoSGBM_t* p);
void                      pCvStereoSGBMSet_P1(StereoSGBM_t* p, int val);
int                       pCvStereoSGBMGet_P2(StereoSGBM_t* p);
void                      pCvStereoSGBMSet_P2(StereoSGBM_t* p, int val);
int                       pCvStereoSGBMGet_SADWindowSize(StereoSGBM_t* p);
void                      pCvStereoSGBMSet_SADWindowSize(StereoSGBM_t* p, int val);
int                       pCvStereoSGBMGet_disp12MaxDiff(StereoSGBM_t* p);
void                      pCvStereoSGBMSet_disp12MaxDiff(StereoSGBM_t* p, int val);
bool                       pCvStereoSGBMGet_fullDP(StereoSGBM_t* p);
void                      pCvStereoSGBMSet_fullDP(StereoSGBM_t* p, bool val);
int                       pCvStereoSGBMGet_minDisparity(StereoSGBM_t* p);
void                      pCvStereoSGBMSet_minDisparity(StereoSGBM_t* p, int val);
int                       pCvStereoSGBMGet_numberOfDisparities(StereoSGBM_t* p);
void                      pCvStereoSGBMSet_numberOfDisparities(StereoSGBM_t* p, int val);
int                       pCvStereoSGBMGet_preFilterCap(StereoSGBM_t* p);
void                      pCvStereoSGBMSet_preFilterCap(StereoSGBM_t* p, int val);
int                       pCvStereoSGBMGet_speckleRange(StereoSGBM_t* p);
void                      pCvStereoSGBMSet_speckleRange(StereoSGBM_t* p, int val);
int                       pCvStereoSGBMGet_speckleWindowSize(StereoSGBM_t* p);
void                      pCvStereoSGBMSet_speckleWindowSize(StereoSGBM_t* p, int val);
int                       pCvStereoSGBMGet_uniquenessRatio(StereoSGBM_t* p);
void                      pCvStereoSGBMSet_uniquenessRatio(StereoSGBM_t* p, int val);
void                      pCvStereoVarcompute(struct  StereoVar_t* wrapper, Mat_t* left, Mat_t* right, Mat_t* disp);
int                       pCvStereoVarGet_cycle(StereoVar_t* p);
void                      pCvStereoVarSet_cycle(StereoVar_t* p, int val);
float                       pCvStereoVarGet_fi(StereoVar_t* p);
void                      pCvStereoVarSet_fi(StereoVar_t* p, float val);
int                       pCvStereoVarGet_flags(StereoVar_t* p);
void                      pCvStereoVarSet_flags(StereoVar_t* p, int val);
float                       pCvStereoVarGet_lambda(StereoVar_t* p);
void                      pCvStereoVarSet_lambda(StereoVar_t* p, float val);
int                       pCvStereoVarGet_levels(StereoVar_t* p);
void                      pCvStereoVarSet_levels(StereoVar_t* p, int val);
int                       pCvStereoVarGet_maxDisp(StereoVar_t* p);
void                      pCvStereoVarSet_maxDisp(StereoVar_t* p, int val);
int                       pCvStereoVarGet_minDisp(StereoVar_t* p);
void                      pCvStereoVarSet_minDisp(StereoVar_t* p, int val);
int                       pCvStereoVarGet_nIt(StereoVar_t* p);
void                      pCvStereoVarSet_nIt(StereoVar_t* p, int val);
int                       pCvStereoVarGet_penalization(StereoVar_t* p);
void                      pCvStereoVarSet_penalization(StereoVar_t* p, int val);
int                       pCvStereoVarGet_poly_n(StereoVar_t* p);
void                      pCvStereoVarSet_poly_n(StereoVar_t* p, int val);
double                       pCvStereoVarGet_poly_sigma(StereoVar_t* p);
void                      pCvStereoVarSet_poly_sigma(StereoVar_t* p, double val);
double                       pCvStereoVarGet_pyrScale(StereoVar_t* p);
void                      pCvStereoVarSet_pyrScale(StereoVar_t* p, double val);
int                       pCvSubdiv2DedgeDst(struct  Subdiv2D_t* wrapper, int edge, Point2f_t* dstpt /* default: 0 */);
int                       pCvSubdiv2DedgeOrg(struct  Subdiv2D_t* wrapper, int edge, Point2f_t* orgpt /* default: 0 */);
int                       pCvSubdiv2DfindNearest(struct  Subdiv2D_t* wrapper, Point2f_t* pt, Point2f_t* nearestPt /* default: 0 */);
int                       pCvSubdiv2DgetEdge(struct  Subdiv2D_t* wrapper, int edge, int nextEdgeType);
void                      pCvSubdiv2DgetEdgeList(struct  Subdiv2D_t* wrapper, vector_Vec4f* edgeList);
void                      pCvSubdiv2DgetTriangleList(struct  Subdiv2D_t* wrapper, vector_Vec6f* triangleList);
Point2f_t*                pCvSubdiv2DgetVertex(struct  Subdiv2D_t* wrapper, int vertex, int* firstEdge /* default: 0 */);
void                      pCvSubdiv2DgetVoronoiFacetList(struct  Subdiv2D_t* wrapper, vector_int* idx, vector_vector_Point2f* facetList, vector_Point2f* facetCenters);
void                      pCvSubdiv2DinitDelaunay(struct  Subdiv2D_t* wrapper, Rect_t* rect);
int                       pCvSubdiv2Dinsert(struct  Subdiv2D_t* wrapper, Point2f_t* pt);
void                      pCvSubdiv2Dinsert2(struct  Subdiv2D_t* wrapper, vector_Point2f* ptvec);
int                       pCvSubdiv2Dlocate(struct  Subdiv2D_t* wrapper, Point2f_t* pt, int edge, int vertex);
int                       pCvSubdiv2DnextEdge(struct  Subdiv2D_t* wrapper, int edge);
int                       pCvSubdiv2DrotateEdge(struct  Subdiv2D_t* wrapper, int edge, int rotate);
int                       pCvSubdiv2DsymEdge(struct  Subdiv2D_t* wrapper, int edge);
double                    pCvVideoCaptureget(struct  VideoCapture_t* wrapper, int propId);
bool                      pCvVideoCapturegrab(struct  VideoCapture_t* wrapper);
bool                      pCvVideoCaptureisOpened(struct  VideoCapture_t* wrapper);
bool                      pCvVideoCaptureopen(struct  VideoCapture_t* wrapper, string_t* filename);
bool                      pCvVideoCaptureopen2(struct  VideoCapture_t* wrapper, int device);
bool                      pCvVideoCaptureread(struct  VideoCapture_t* wrapper, Mat_t* image);
void                      pCvVideoCapturerelease(struct  VideoCapture_t* wrapper);
bool                      pCvVideoCaptureretrieve(struct  VideoCapture_t* wrapper, Mat_t* image, int channel /* default: 0 */);
bool                      pCvVideoCaptureset(struct  VideoCapture_t* wrapper, int propId, double value);
bool                      pCvVideoWriterisOpened(struct  VideoWriter_t* wrapper);
bool                      pCvVideoWriteropen(struct  VideoWriter_t* wrapper, string_t* filename, int fourcc, double fps, Size_t* frameSize, bool isColor /* default: true */);
void                      pCvVideoWriterrelease(struct  VideoWriter_t* wrapper);
void                      pCvVideoWriterwrite(struct  VideoWriter_t* wrapper, Mat_t* image);
void                      pCvflann_Indexbuild(struct  flann_Index_t* wrapper, Mat_t* wholefeatures, Mat_t* additionalfeatures, IndexParams_t* params, cvflann_flann_distance_t distType /* default: cvflann::FLANN_DIST_L2 */);
cvflann_flann_algorithm_t pCvflann_IndexgetAlgorithm(struct  flann_Index_t* wrapper);
cvflann_flann_distance_t  pCvflann_IndexgetDistance(struct  flann_Index_t* wrapper);
void                      pCvflann_IndexknnSearch(struct  flann_Index_t* wrapper, Mat_t* query, Mat_t* indices, Mat_t* dists, int knn, SearchParams_t* params /* default: SearchParams() */);
bool                      pCvflann_Indexload(struct  flann_Index_t* wrapper, Mat_t* features, string_t* filename);
int                       pCvflann_IndexradiusSearch(struct  flann_Index_t* wrapper, Mat_t* query, Mat_t* indices, Mat_t* dists, double radius, int maxResults, SearchParams_t* params /* default: SearchParams() */);
void                      pCvflann_Indexrelease(struct  flann_Index_t* wrapper);
void                      pCvflann_Indexsave(struct  flann_Index_t* wrapper, string_t* filename);
Ptr_Algorithm*            pCvAlgorithm__create(string_t* name);
void                      pCvAlgorithm_getList(vector_string* algorithms);
RotatedRect_t*            pCvCamShift(Mat_t* probImage, Rect_t* window, TermCriteria_t* criteria);
void                      pCvCanny(Mat_t* image, Mat_t* edges, double threshold1, double threshold2, int apertureSize /* default: 3 */, bool L2gradient /* default: false */);
Ptr_DescriptorExtractor*  pCvDescriptorExtractor_create(string_t* descriptorExtractorType);
Ptr_DescriptorMatcher*    pCvDescriptorMatcher_create(string_t* descriptorMatcherType);
Ptr_Feature2D*            pCvFeature2D_create(string_t* name);
Ptr_FeatureDetector*      pCvFeatureDetector_create(string_t* detectorType);
void                      pCvGaussianBlur(Mat_t* src, Mat_t* dst, Size_t* ksize, double sigmaX, double sigmaY /* default: 0 */, int borderType /* default: BORDER_DEFAULT */);
vector_float*             pCvHOGDescriptor_getDaimlerPeopleDetector();
vector_float*             pCvHOGDescriptor_getDefaultPeopleDetector();
void                      pCvHoughCircles(Mat_t* image, Mat_t* circles, int method, double dp, double minDist, double param1 /* default: 100 */, double param2 /* default: 100 */, int minRadius /* default: 0 */, int maxRadius /* default: 0 */);
void                      pCvHoughLines(Mat_t* image, Mat_t* lines, double rho, double theta, int threshold, double srn /* default: 0 */, double stn /* default: 0 */);
void                      pCvHoughLinesP(Mat_t* image, Mat_t* lines, double rho, double theta, int threshold, double minLineLength /* default: 0 */, double maxLineGap /* default: 0 */);
void                      pCvHuMoments(Moments_t* m, Mat_t* hu);
void                      pCvLUT(Mat_t* src, Mat_t* lut, Mat_t* dst, int interpolation /* default: 0 */);
void                      pCvLaplacian(Mat_t* src, Mat_t* dst, int ddepth, int ksize /* default: 1 */, double scale /* default: 1 */, double delta /* default: 0 */, int borderType /* default: BORDER_DEFAULT */);
double                    pCvMahalanobis(Mat_t* v1, Mat_t* v2, Mat_t* icovar);
void                      pCvPCABackProject(Mat_t* data, Mat_t* mean, Mat_t* eigenvectors, Mat_t* result);
void                      pCvPCACompute(Mat_t* data, Mat_t* mean, Mat_t* eigenvectors, int maxComponents /* default: 0 */);
void                      pCvPCAComputeVar(Mat_t* data, Mat_t* mean, Mat_t* eigenvectors, double retainedVariance);
void                      pCvPCAProject(Mat_t* data, Mat_t* mean, Mat_t* eigenvectors, Mat_t* result);
double                    pCvPSNR(Mat_t* src1, Mat_t* src2);
Vec3d_t*                  pCvRQDecomp3x3(Mat_t* src, Mat_t* mtxR, Mat_t* mtxQ, Mat_t* Qx /* default: Mat() */, Mat_t* Qy /* default: Mat() */, Mat_t* Qz /* default: Mat() */);
void                      pCvRodrigues(Mat_t* src, Mat_t* dst, Mat_t* jacobian /* default: Mat() */);
void                      pCvSVBackSubst(Mat_t* w, Mat_t* u, Mat_t* vt, Mat_t* rhs, Mat_t* dst);
void                      pCvSVDecomp(Mat_t* src, Mat_t* w, Mat_t* u, Mat_t* vt, int flags /* default: 0 */);
void                      pCvScharr(Mat_t* src, Mat_t* dst, int ddepth, int dx, int dy, double scale /* default: 1 */, double delta /* default: 0 */, int borderType /* default: BORDER_DEFAULT */);
void                      pCvSobel(Mat_t* src, Mat_t* dst, int ddepth, int dx, int dy, int ksize /* default: 3 */, double scale /* default: 1 */, double delta /* default: 0 */, int borderType /* default: BORDER_DEFAULT */);
void                      pCvabsdiff(Mat_t* src1, Mat_t* src2, Mat_t* dst);
void                      pCvaccumulate(Mat_t* src, Mat_t* dst, Mat_t* mask /* default: Mat() */);
void                      pCvaccumulateProduct(Mat_t* src1, Mat_t* src2, Mat_t* dst, Mat_t* mask /* default: Mat() */);
void                      pCvaccumulateSquare(Mat_t* src, Mat_t* dst, Mat_t* mask /* default: Mat() */);
void                      pCvaccumulateWeighted(Mat_t* src, Mat_t* dst, double alpha, Mat_t* mask /* default: Mat() */);
void                      pCvadaptiveBilateralFilter(Mat_t* src, Mat_t* dst, Size_t* ksize, double sigmaSpace, double maxSigmaColor /* default: 20.0 */, Point_t* anchor /* default: Point(-1, -1) */, int borderType /* default: BORDER_DEFAULT */);
void                      pCvadaptiveThreshold(Mat_t* src, Mat_t* dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C);
void                      pCvadd(Mat_t* src1, Mat_t* src2, Mat_t* dst, Mat_t* mask /* default: Mat() */, int dtype /* default: -1 */);
void                      pCvaddWeighted(Mat_t* src1, double alpha, Mat_t* src2, double beta, double gamma, Mat_t* dst, int dtype /* default: -1 */);
void                      pCvapplyColorMap(Mat_t* src, Mat_t* dst, int colormap);
void                      pCvapproxPolyDP(Mat_t* curve, Mat_t* approxCurve, double epsilon, bool closed);
double                    pCvarcLength(Mat_t* curve, bool closed);
void                      pCvarrowedLine(Mat_t* img, Point_t* pt1, Point_t* pt2, Scalar_t* color, int thickness /* default: 1 */, int line_type /* default: 8 */, int shift /* default: 0 */, double tipLength /* default: 0.1 */);
void                      pCvbatchDistance(Mat_t* src1, Mat_t* src2, Mat_t* dist, int dtype, Mat_t* nidx, int normType /* default: NORM_L2 */, int K /* default: 0 */, Mat_t* mask /* default: Mat() */, int update /* default: 0 */, bool crosscheck /* default: false */);
void                      pCvbilateralFilter(Mat_t* src, Mat_t* dst, int d, double sigmaColor, double sigmaSpace, int borderType /* default: BORDER_DEFAULT */);
void                      pCvbitwise_and(Mat_t* src1, Mat_t* src2, Mat_t* dst, Mat_t* mask /* default: Mat() */);
void                      pCvbitwise_not(Mat_t* src, Mat_t* dst, Mat_t* mask /* default: Mat() */);
void                      pCvbitwise_or(Mat_t* src1, Mat_t* src2, Mat_t* dst, Mat_t* mask /* default: Mat() */);
void                      pCvbitwise_xor(Mat_t* src1, Mat_t* src2, Mat_t* dst, Mat_t* mask /* default: Mat() */);
void                      pCvblur(Mat_t* src, Mat_t* dst, Size_t* ksize, Point_t* anchor /* default: Point(-1,-1) */, int borderType /* default: BORDER_DEFAULT */);
int                       pCvborderInterpolate(int p, int len, int borderType);
Rect_t*                   pCvboundingRect(Mat_t* points);
void                      pCvboxFilter(Mat_t* src, Mat_t* dst, int ddepth, Size_t* ksize, Point_t* anchor /* default: Point(-1,-1) */, bool normalize /* default: true */, int borderType /* default: BORDER_DEFAULT */);
int                       pCvbuildOpticalFlowPyramid(Mat_t* img, vector_Mat* pyramid, Size_t* winSize, int maxLevel, bool withDerivatives /* default: true */, int pyrBorder /* default: BORDER_REFLECT_101 */, int derivBorder /* default: BORDER_CONSTANT */, bool tryReuseInputImage /* default: true */);
void                      pCvcalcBackProject(vector_Mat* images, vector_int* channels, Mat_t* hist, Mat_t* dst, vector_float* ranges, double scale);
void                      pCvcalcCovarMatrix(Mat_t* samples, Mat_t* covar, Mat_t* mean, int flags, int ctype /* default: CV_64F */);
double                    pCvcalcGlobalOrientation(Mat_t* orientation, Mat_t* mask, Mat_t* mhi, double timestamp, double duration);
void                      pCvcalcHist(vector_Mat* images, vector_int* channels, Mat_t* mask, Mat_t* hist, vector_int* histSize, vector_float* ranges, bool accumulate /* default: false */);
void                      pCvcalcMotionGradient(Mat_t* mhi, Mat_t* mask, Mat_t* orientation, double delta1, double delta2, int apertureSize /* default: 3 */);
void                      pCvcalcOpticalFlowFarneback(Mat_t* prev, Mat_t* next, Mat_t* flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags);
void                      pCvcalcOpticalFlowPyrLK(Mat_t* prevImg, Mat_t* nextImg, Mat_t* prevPts, Mat_t* nextPts, Mat_t* status, Mat_t* err, Size_t* winSize /* default: Size(21,21) */, int maxLevel /* default: 3 */, TermCriteria_t* criteria /* default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01) */, int flags /* default: 0 */, double minEigThreshold /* default: 1e-4 */);
void                      pCvcalcOpticalFlowSF(Mat_t* from, Mat_t* _to, Mat_t* flow, int layers, int averaging_block_size, int max_flow);
void                      pCvcalcOpticalFlowSF2(Mat_t* from, Mat_t* _to, Mat_t* flow, int layers, int averaging_block_size, int max_flow, double sigma_dist, double sigma_color, int postprocess_window, double sigma_dist_fix, double sigma_color_fix, double occ_thr, int upscale_averaging_radius, double upscale_sigma_dist, double upscale_sigma_color, double speed_up_thr);
double                    pCvcalibrateCamera(vector_Mat* objectPoints, vector_Mat* imagePoints, Size_t* imageSize, Mat_t* cameraMatrix, Mat_t* distCoeffs, vector_Mat* rvecs, vector_Mat* tvecs, int flags /* default: 0 */, TermCriteria_t* criteria /* default: TermCriteria( TermCriteria::COUNT+TermCriteria::EPS, 30, DBL_EPSILON) */);
void                      pCvcalibrationMatrixValues(Mat_t* cameraMatrix, Size_t* imageSize, double apertureWidth, double apertureHeight, double fovx, double fovy, double focalLength, Point2d_t* principalPoint, double aspectRatio);
void                      pCvcartToPolar(Mat_t* x, Mat_t* y, Mat_t* magnitude, Mat_t* angle, bool angleInDegrees /* default: false */);
int                       pCvchamerMatching(Mat_t* img, Mat_t* templ, vector_vector_Point* results, vector_float* cost, double templScale /* default: 1 */, int maxMatches /* default: 20 */, double minMatchDistance /* default: 1.0 */, int padX /* default: 3 */, int padY /* default: 3 */, int scales /* default: 5 */, double minScale /* default: 0.6 */, double maxScale /* default: 1.6 */, double orientationWeight /* default: 0.5 */, double truncate /* default: 20 */);
bool                      pCvcheckHardwareSupport(int feature);
bool                      pCvcheckRange(Mat_t* a, bool quiet /* default: true */, Point_t* pos /* default: 0 */, double minVal /* default: -DBL_MAX */, double maxVal /* default: DBL_MAX */);
void                      pCvcircle(Mat_t* img, Point_t* center, int radius, Scalar_t* color, int thickness /* default: 1 */, int lineType /* default: 8 */, int shift /* default: 0 */);
bool                      pCvclipLine(Rect_t* imgRect, Point_t* pt1, Point_t* pt2);
void                      pCvcompare(Mat_t* src1, Mat_t* src2, Mat_t* dst, int cmpop);
double                    pCvcompareHist(Mat_t* H1, Mat_t* H2, int method);
void                      pCvcompleteSymm(Mat_t* mtx, bool lowerToUpper /* default: false */);
void                      pCvcomposeRT(Mat_t* rvec1, Mat_t* tvec1, Mat_t* rvec2, Mat_t* tvec2, Mat_t* rvec3, Mat_t* tvec3, Mat_t* dr3dr1 /* default: Mat() */, Mat_t* dr3dt1 /* default: Mat() */, Mat_t* dr3dr2 /* default: Mat() */, Mat_t* dr3dt2 /* default: Mat() */, Mat_t* dt3dr1 /* default: Mat() */, Mat_t* dt3dt1 /* default: Mat() */, Mat_t* dt3dr2 /* default: Mat() */, Mat_t* dt3dt2 /* default: Mat() */);
void                      pCvcomputeCorrespondEpilines(Mat_t* points, int whichImage, Mat_t* F, Mat_t* lines);
double                    pCvcontourArea(Mat_t* contour, bool oriented /* default: false */);
void                      pCvconvertMaps(Mat_t* map1, Mat_t* map2, Mat_t* dstmap1, Mat_t* dstmap2, int dstmap1type, bool nninterpolation /* default: false */);
void                      pCvconvertPointsFromHomogeneous(Mat_t* src, Mat_t* dst);
void                      pCvconvertPointsToHomogeneous(Mat_t* src, Mat_t* dst);
void                      pCvconvertScaleAbs(Mat_t* src, Mat_t* dst, double alpha /* default: 1 */, double beta /* default: 0 */);
void                      pCvconvexHull(Mat_t* points, Mat_t* hull, bool clockwise /* default: false */, bool returnPoints /* default: true */);
void                      pCvconvexityDefects(Mat_t* contour, Mat_t* convexhull, Mat_t* convexityDefects);
void                      pCvcopyMakeBorder(Mat_t* src, Mat_t* dst, int top, int bottom, int left, int right, int borderType, Scalar_t* value /* default: Scalar() */);
void                      pCvcornerEigenValsAndVecs(Mat_t* src, Mat_t* dst, int blockSize, int ksize, int borderType /* default: BORDER_DEFAULT */);
void                      pCvcornerHarris(Mat_t* src, Mat_t* dst, int blockSize, int ksize, double k, int borderType /* default: BORDER_DEFAULT */);
void                      pCvcornerMinEigenVal(Mat_t* src, Mat_t* dst, int blockSize, int ksize /* default: 3 */, int borderType /* default: BORDER_DEFAULT */);
void                      pCvcornerSubPix(Mat_t* image, Mat_t* corners, Size_t* winSize, Size_t* zeroZone, TermCriteria_t* criteria);
void                      pCvcorrectMatches(Mat_t* F, Mat_t* points1, Mat_t* points2, Mat_t* newPoints1, Mat_t* newPoints2);
int                       pCvcountNonZero(Mat_t* src);
Ptr_CLAHE*                pCvcreateCLAHE(double clipLimit /* default: 40.0 */, Size_t* tileGridSize /* default: Size(8, 8) */);
Ptr_FaceRecognizer*       pCvcreateEigenFaceRecognizer(int num_components /* default: 0 */, double threshold /* default: DBL_MAX */);
Ptr_FaceRecognizer*       pCvcreateFisherFaceRecognizer(int num_components /* default: 0 */, double threshold /* default: DBL_MAX */);
void                      pCvcreateHanningWindow(Mat_t* dst, Size_t* winSize, int _type);
Ptr_FaceRecognizer*       pCvcreateLBPHFaceRecognizer(int radius /* default: 1 */, int neighbors /* default: 8 */, int grid_x /* default: 8 */, int grid_y /* default: 8 */, double threshold /* default: DBL_MAX */);
float                     pCvcubeRoot(float val);
void                      pCvcvtColor(Mat_t* src, Mat_t* dst, int code, int dstCn /* default: 0 */);
void                      pCvdct(Mat_t* src, Mat_t* dst, int flags /* default: 0 */);
void                      pCvdecomposeProjectionMatrix(Mat_t* projMatrix, Mat_t* cameraMatrix, Mat_t* rotMatrix, Mat_t* transVect, Mat_t* rotMatrixX /* default: Mat() */, Mat_t* rotMatrixY /* default: Mat() */, Mat_t* rotMatrixZ /* default: Mat() */, Mat_t* eulerAngles /* default: Mat() */);
void                      pCvdestroyAllWindows();
void                      pCvdestroyWindow(string_t* winname);
double                    pCvdeterminant(Mat_t* mtx);
void                      pCvdft(Mat_t* src, Mat_t* dst, int flags /* default: 0 */, int nonzeroRows /* default: 0 */);
void                      pCvdilate(Mat_t* src, Mat_t* dst, Mat_t* kernel, Point_t* anchor /* default: Point(-1,-1) */, int iterations /* default: 1 */, int borderType /* default: BORDER_CONSTANT */, Scalar_t* borderValue /* default: morphologyDefaultBorderValue() */);
void                      pCvdistanceTransform(Mat_t* src, Mat_t* dst, int distanceType, int maskSize);
void                      pCvdistanceTransformWithLabels(Mat_t* src, Mat_t* dst, Mat_t* labels, int distanceType, int maskSize, int labelType /* default: DIST_LABEL_CCOMP */);
void                      pCvdivide(Mat_t* src1, Mat_t* src2, Mat_t* dst, double scale /* default: 1 */, int dtype /* default: -1 */);
void                      pCvdivide2(double scale, Mat_t* src2, Mat_t* dst, int dtype /* default: -1 */);
void                      pCvdrawChessboardCorners(Mat_t* image, Size_t* patternSize, Mat_t* corners, bool patternWasFound);
void                      pCvdrawContours(Mat_t* image, vector_Mat* contours, int contourIdx, Scalar_t* color, int thickness /* default: 1 */, int lineType /* default: 8 */, Mat_t* hierarchy /* default: Mat() */, int maxLevel /* default: INT_MAX */, Point_t* offset /* default: Point() */);
void                      pCvdrawDataMatrixCodes(Mat_t* image, vector_string* codes, Mat_t* corners);
void                      pCvdrawKeypoints(Mat_t* image, vector_KeyPoint* keypoints, Mat_t* outImage, Scalar_t* color /* default: Scalar::all(-1) */, int flags /* default: DrawMatchesFlags::DEFAULT */);
void                      pCvdrawMarker(Mat_t* img, Point_t* position, Scalar_t* color, int markerType /* default: MARKER_CROSS */, int markerSize /* default: 20 */, int thickness /* default: 1 */, int line_type /* default: 8 */);
bool                      pCveigen(Mat_t* src, bool computeEigenvectors, Mat_t* eigenvalues, Mat_t* eigenvectors);
void                      pCvellipse(Mat_t* img, Point_t* center, Size_t* axes, double angle, double startAngle, double endAngle, Scalar_t* color, int thickness /* default: 1 */, int lineType /* default: 8 */, int shift /* default: 0 */);
void                      pCvellipse2(Mat_t* img, RotatedRect_t* box, Scalar_t* color, int thickness /* default: 1 */, int lineType /* default: 8 */);
void                      pCvellipse2Poly(Point_t* center, Size_t* axes, int angle, int arcStart, int arcEnd, int delta, vector_Point* pts);
void                      pCvequalizeHist(Mat_t* src, Mat_t* dst);
void                      pCverode(Mat_t* src, Mat_t* dst, Mat_t* kernel, Point_t* anchor /* default: Point(-1,-1) */, int iterations /* default: 1 */, int borderType /* default: BORDER_CONSTANT */, Scalar_t* borderValue /* default: morphologyDefaultBorderValue() */);
int                       pCvestimateAffine3D(Mat_t* src, Mat_t* dst, Mat_t* out, Mat_t* inliers, double ransacThreshold /* default: 3 */, double confidence /* default: 0.99 */);
Mat_t*                    pCvestimateRigidTransform(Mat_t* src, Mat_t* dst, bool fullAffine);
void                      pCvexp(Mat_t* src, Mat_t* dst);
void                      pCvextractChannel(Mat_t* src, Mat_t* dst, int coi);
float                     pCvfastAtan2(float y, float x);
void                      pCvfastNlMeansDenoising(Mat_t* src, Mat_t* dst, float h /* default: 3 */, int templateWindowSize /* default: 7 */, int searchWindowSize /* default: 21 */);
void                      pCvfastNlMeansDenoisingColored(Mat_t* src, Mat_t* dst, float h /* default: 3 */, float hColor /* default: 3 */, int templateWindowSize /* default: 7 */, int searchWindowSize /* default: 21 */);
void                      pCvfastNlMeansDenoisingColoredMulti(vector_Mat* srcImgs, Mat_t* dst, int imgToDenoiseIndex, int temporalWindowSize, float h /* default: 3 */, float hColor /* default: 3 */, int templateWindowSize /* default: 7 */, int searchWindowSize /* default: 21 */);
void                      pCvfastNlMeansDenoisingMulti(vector_Mat* srcImgs, Mat_t* dst, int imgToDenoiseIndex, int temporalWindowSize, float h /* default: 3 */, int templateWindowSize /* default: 7 */, int searchWindowSize /* default: 21 */);
void                      pCvfillConvexPoly(Mat_t* img, Mat_t* points, Scalar_t* color, int lineType /* default: 8 */, int shift /* default: 0 */);
void                      pCvfillPoly(Mat_t* img, vector_Mat* pts, Scalar_t* color, int lineType /* default: 8 */, int shift /* default: 0 */, Point_t* offset /* default: Point() */);
void                      pCvfilter2D(Mat_t* src, Mat_t* dst, int ddepth, Mat_t* kernel, Point_t* anchor /* default: Point(-1,-1) */, double delta /* default: 0 */, int borderType /* default: BORDER_DEFAULT */);
void                      pCvfilterSpeckles(Mat_t* img, double newVal, int maxSpeckleSize, double maxDiff, Mat_t* buf /* default: Mat() */);
bool                      pCvfindChessboardCorners(Mat_t* image, Size_t* patternSize, Mat_t* corners, int flags /* default: CALIB_CB_ADAPTIVE_THRESH+CALIB_CB_NORMALIZE_IMAGE */);
bool                      pCvfindCirclesGrid(Mat_t* image, Size_t* patternSize, Mat_t* centers, int flags /* default: CALIB_CB_SYMMETRIC_GRID */, Ptr_FeatureDetector* blobDetector /* default: new SimpleBlobDetector() */);
bool                      pCvfindCirclesGridDefault(Mat_t* image, Size_t* patternSize, Mat_t* centers, int flags /* default: CALIB_CB_SYMMETRIC_GRID */);
void                      pCvfindContours(Mat_t* image, vector_Mat* contours, Mat_t* hierarchy, int mode, int method, Point_t* offset /* default: Point() */);
void                      pCvfindDataMatrix(Mat_t* image, vector_string* codes, Mat_t* corners /* default: Mat() */, vector_Mat* dmtx /* default: vector_Mat() */);
Mat_t*                    pCvfindFundamentalMat(Mat_t* points1, Mat_t* points2, int method /* default: FM_RANSAC */, double param1 /* default: 3. */, double param2 /* default: 0.99 */, Mat_t* mask /* default: Mat() */);
Mat_t*                    pCvfindHomography(Mat_t* srcPoints, Mat_t* dstPoints, int method /* default: 0 */, double ransacReprojThreshold /* default: 3 */, Mat_t* mask /* default: Mat() */);
void                      pCvfindNonZero(Mat_t* src, Mat_t* idx);
RotatedRect_t*            pCvfitEllipse(Mat_t* points);
void                      pCvfitLine(Mat_t* points, Mat_t* line, int distType, double param, double reps, double aeps);
void                      pCvflip(Mat_t* src, Mat_t* dst, int flipCode);
int                       pCvfloodFill(Mat_t* image, Mat_t* mask, Point_t* seedPoint, Scalar_t* newVal, Rect_t* rect /* default: 0 */, Scalar_t* loDiff /* default: Scalar() */, Scalar_t* upDiff /* default: Scalar() */, int flags /* default: 4 */);
void                      pCvgemm(Mat_t* src1, Mat_t* src2, double alpha, Mat_t* src3, double beta, Mat_t* dst, int flags /* default: 0 */);
Mat_t*                    pCvgetAffineTransform(Mat_t* src, Mat_t* dst);
string_t*                 pCvgetBuildInformation();
int64                     pCvgetCPUTickCount();
Mat_t*                    pCvgetDefaultNewCameraMatrix(Mat_t* cameraMatrix, Size_t* imgsize /* default: Size() */, bool centerPrincipalPoint /* default: false */);
void                      pCvgetDerivKernels(Mat_t* kx, Mat_t* ky, int dx, int dy, int ksize, bool normalize /* default: false */, int ktype /* default: CV_32F */);
Mat_t*                    pCvgetGaborKernel(Size_t* ksize, double sigma, double theta, double lambd, double gamma, double psi /* default: CV_PI*0.5 */, int ktype /* default: CV_64F */);
Mat_t*                    pCvgetGaussianKernel(int ksize, double sigma, int ktype /* default: CV_64F */);
int                       pCvgetNumThreads();
int                       pCvgetNumberOfCPUs();
int                       pCvgetOptimalDFTSize(int vecsize);
Mat_t*                    pCvgetOptimalNewCameraMatrix(Mat_t* cameraMatrix, Mat_t* distCoeffs, Size_t* imageSize, double alpha, Size_t* newImgSize /* default: Size() */, Rect_t* validPixROI /* default: 0 */, bool centerPrincipalPoint /* default: false */);
Mat_t*                    pCvgetPerspectiveTransform(Mat_t* src, Mat_t* dst);
void                      pCvgetRectSubPix(Mat_t* image, Size_t* patchSize, Point2f_t* center, Mat_t* patch, int patchType /* default: -1 */);
Mat_t*                    pCvgetRotationMatrix2D(Point2f_t* center, double angle, double scale);
Mat_t*                    pCvgetStructuringElement(int shape, Size_t* ksize, Point_t* anchor /* default: Point(-1,-1) */);
Size_t*                   pCvgetTextSize(string_t* text, int fontFace, double fontScale, int thickness, int* baseLine);
int                       pCvgetThreadNum();
int64                     pCvgetTickCount();
double                    pCvgetTickFrequency();
int                       pCvgetTrackbarPos(string_t* trackbarname, string_t* winname);
Rect_t*                   pCvgetValidDisparityROI(Rect_t* roi1, Rect_t* roi2, int minDisparity, int numberOfDisparities, int SADWindowSize);
double                    pCvgetWindowProperty(string_t* winname, int prop_id);
void                      pCvgoodFeaturesToTrack(Mat_t* image, Mat_t* corners, int maxCorners, double qualityLevel, double minDistance, Mat_t* mask /* default: Mat() */, int blockSize /* default: 3 */, bool useHarrisDetector /* default: false */, double k /* default: 0.04 */);
void                      pCvgrabCut(Mat_t* img, Mat_t* mask, Rect_t* rect, Mat_t* bgdModel, Mat_t* fgdModel, int iterCount, int mode /* default: GC_EVAL */);
void                      pCvgroupRectangles(vector_Rect* rectList, vector_int* weights, int groupThreshold, double eps /* default: 0.2 */);
void                      pCvhconcat(vector_Mat* src, Mat_t* dst);
void                      pCvidct(Mat_t* src, Mat_t* dst, int flags /* default: 0 */);
void                      pCvidft(Mat_t* src, Mat_t* dst, int flags /* default: 0 */, int nonzeroRows /* default: 0 */);
Mat_t*                    pCvimdecode(Mat_t* buf, int flags);
bool                      pCvimencode(string_t* ext, Mat_t* img, vector_uchar* buf, vector_int* params /* default: vector<int>() */);
Mat_t*                    pCvimread(string_t* filename, int flags /* default: 1 */);
void                      pCvimshow(string_t* winname, Mat_t* mat);
bool                      pCvimwrite(string_t* filename, Mat_t* img, vector_int* params /* default: vector<int>() */);
void                      pCvinRange(Mat_t* src, Mat_t* lowerb, Mat_t* upperb, Mat_t* dst);
Mat_t*                    pCvinitCameraMatrix2D(vector_Mat* objectPoints, vector_Mat* imagePoints, Size_t* imageSize, double aspectRatio /* default: 1. */);
bool                      pCvinitModule_nonfree();
void                      pCvinitUndistortRectifyMap(Mat_t* cameraMatrix, Mat_t* distCoeffs, Mat_t* R, Mat_t* newCameraMatrix, Size_t* size, int m1type, Mat_t* map1, Mat_t* map2);
float                     pCvinitWideAngleProjMap(Mat_t* cameraMatrix, Mat_t* distCoeffs, Size_t* imageSize, int destImageWidth, int m1type, Mat_t* map1, Mat_t* map2, int projType /* default: PROJ_SPHERICAL_EQRECT */, double alpha /* default: 0 */);
void                      pCvinpaint(Mat_t* src, Mat_t* inpaintMask, Mat_t* dst, double inpaintRadius, int flags);
void                      pCvinsertChannel(Mat_t* src, Mat_t* dst, int coi);
void                      pCvintegral(Mat_t* src, Mat_t* sum, int sdepth /* default: -1 */);
void                      pCvintegral2(Mat_t* src, Mat_t* sum, Mat_t* sqsum, int sdepth /* default: -1 */);
void                      pCvintegral3(Mat_t* src, Mat_t* sum, Mat_t* sqsum, Mat_t* tilted, int sdepth /* default: -1 */);
float                     pCvintersectConvexConvex(Mat_t* _p1, Mat_t* _p2, Mat_t* _p12, bool handleNested /* default: true */);
double                    pCvinvert(Mat_t* src, Mat_t* dst, int flags /* default: DECOMP_LU */);
void                      pCvinvertAffineTransform(Mat_t* M, Mat_t* iM);
bool                      pCvisContourConvex(Mat_t* contour);
double                    pCvkmeans(Mat_t* data, int K, Mat_t* bestLabels, TermCriteria_t* criteria, int attempts, int flags, Mat_t* centers /* default: Mat() */);
void                      pCvline(Mat_t* img, Point_t* pt1, Point_t* pt2, Scalar_t* color, int thickness /* default: 1 */, int lineType /* default: 8 */, int shift /* default: 0 */);
void                      pCvlog(Mat_t* src, Mat_t* dst);
void                      pCvmagnitude(Mat_t* x, Mat_t* y, Mat_t* magnitude);
void                      pCvmatMulDeriv(Mat_t* A, Mat_t* B, Mat_t* dABdA, Mat_t* dABdB);
double                    pCvmatchShapes(Mat_t* contour1, Mat_t* contour2, int method, double parameter);
void                      pCvmatchTemplate(Mat_t* image, Mat_t* templ, Mat_t* result, int method);
void                      pCvmax(Mat_t* src1, Mat_t* src2, Mat_t* dst);
Scalar_t*                 pCvmean(Mat_t* src, Mat_t* mask /* default: Mat() */);
int                       pCvmeanShift(Mat_t* probImage, Rect_t* window, TermCriteria_t* criteria);
void                      pCvmeanStdDev(Mat_t* src, Mat_t* mean, Mat_t* stddev, Mat_t* mask /* default: Mat() */);
void                      pCvmedianBlur(Mat_t* src, Mat_t* dst, int ksize);
void                      pCvmerge(vector_Mat* mv, Mat_t* dst);
void                      pCvmin(Mat_t* src1, Mat_t* src2, Mat_t* dst);
RotatedRect_t*            pCvminAreaRect(Mat_t* points);
void                      pCvminEnclosingCircle(Mat_t* points, Point2f_t* center, float radius);
void                      pCvminMaxLoc(Mat_t* src, double* minVal, double* maxVal /* default: 0 */, Point_t* minLoc /* default: 0 */, Point_t* maxLoc /* default: 0 */, Mat_t* mask /* default: Mat() */);
void                      pCvmixChannels(vector_Mat* src, vector_Mat* dst, vector_int* fromTo);
Moments_t*                pCvmoments(Mat_t* _array, bool binaryImage /* default: false */);
void                      pCvmorphologyEx(Mat_t* src, Mat_t* dst, int op, Mat_t* kernel, Point_t* anchor /* default: Point(-1,-1) */, int iterations /* default: 1 */, int borderType /* default: BORDER_CONSTANT */, Scalar_t* borderValue /* default: morphologyDefaultBorderValue() */);
void                      pCvmoveWindow(string_t* winname, int x, int y);
void                      pCvmulSpectrums(Mat_t* a, Mat_t* b, Mat_t* c, int flags, bool conjB /* default: false */);
void                      pCvmulTransposed(Mat_t* src, Mat_t* dst, bool aTa, Mat_t* delta /* default: Mat() */, double scale /* default: 1 */, int dtype /* default: -1 */);
void                      pCvmultiply(Mat_t* src1, Mat_t* src2, Mat_t* dst, double scale /* default: 1 */, int dtype /* default: -1 */);
void                      pCvnamedWindow(string_t* winname, int flags /* default: WINDOW_AUTOSIZE */);
double                    pCvnorm(Mat_t* src1, int normType /* default: NORM_L2 */, Mat_t* mask /* default: Mat() */);
double                    pCvnorm2(Mat_t* src1, Mat_t* src2, int normType /* default: NORM_L2 */, Mat_t* mask /* default: Mat() */);
void                      pCvnormalize(Mat_t* src, Mat_t* dst, double alpha /* default: 1 */, double beta /* default: 0 */, int norm_type /* default: NORM_L2 */, int dtype /* default: -1 */, Mat_t* mask /* default: Mat() */);
void                      pCvpatchNaNs(Mat_t* a, double val /* default: 0 */);
void                      pCvperspectiveTransform(Mat_t* src, Mat_t* dst, Mat_t* m);
void                      pCvphase(Mat_t* x, Mat_t* y, Mat_t* angle, bool angleInDegrees /* default: false */);
Point2d_t*                pCvphaseCorrelate(Mat_t* src1, Mat_t* src2, Mat_t* window /* default: Mat() */);
Point2d_t*                pCvphaseCorrelateRes(Mat_t* src1, Mat_t* src2, Mat_t* window, double* response /* default: 0 */);
double                    pCvpointPolygonTest(Mat_t* contour, Point2f_t* pt, bool measureDist);
void                      pCvpolarToCart(Mat_t* magnitude, Mat_t* angle, Mat_t* x, Mat_t* y, bool angleInDegrees /* default: false */);
void                      pCvpolylines(Mat_t* img, vector_Mat* pts, bool isClosed, Scalar_t* color, int thickness /* default: 1 */, int lineType /* default: 8 */, int shift /* default: 0 */);
void                      pCvpow(Mat_t* src, double power, Mat_t* dst);
void                      pCvpreCornerDetect(Mat_t* src, Mat_t* dst, int ksize, int borderType /* default: BORDER_DEFAULT */);
void                      pCvprojectPoints(Mat_t* objectPoints, Mat_t* rvec, Mat_t* tvec, Mat_t* cameraMatrix, Mat_t* distCoeffs, Mat_t* imagePoints, Mat_t* jacobian /* default: Mat() */, double aspectRatio /* default: 0 */);
void                      pCvputText(Mat_t* img, string_t* text, Point_t* org, int fontFace, double fontScale, Scalar_t* color, int thickness /* default: 1 */, int lineType /* default: 8 */, bool bottomLeftOrigin /* default: false */);
void                      pCvpyrDown(Mat_t* src, Mat_t* dst, Size_t* dstsize /* default: Size() */, int borderType /* default: BORDER_DEFAULT */);
void                      pCvpyrMeanShiftFiltering(Mat_t* src, Mat_t* dst, double sp, double sr, int maxLevel /* default: 1 */, TermCriteria_t* termcrit /* default: TermCriteria( TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) */);
void                      pCvpyrUp(Mat_t* src, Mat_t* dst, Size_t* dstsize /* default: Size() */, int borderType /* default: BORDER_DEFAULT */);
void                      pCvrandShuffle(Mat_t* dst, double iterFactor /* default: 1. */);
void                      pCvrandn(Mat_t* dst, Mat_t* mean, Mat_t* stddev);
void                      pCvrandu(Mat_t* dst, Mat_t* low, Mat_t* high);
void                      pCvrectangle(Mat_t* img, Point_t* pt1, Point_t* pt2, Scalar_t* color, int thickness /* default: 1 */, int lineType /* default: 8 */, int shift /* default: 0 */);
float                     pCvrectify3Collinear(Mat_t* cameraMatrix1, Mat_t* distCoeffs1, Mat_t* cameraMatrix2, Mat_t* distCoeffs2, Mat_t* cameraMatrix3, Mat_t* distCoeffs3, vector_Mat* imgpt1, vector_Mat* imgpt3, Size_t* imageSize, Mat_t* R12, Mat_t* T12, Mat_t* R13, Mat_t* T13, Mat_t* R1, Mat_t* R2, Mat_t* R3, Mat_t* P1, Mat_t* P2, Mat_t* P3, Mat_t* Q, double alpha, Size_t* newImgSize, Rect_t* roi1, Rect_t* roi2, int flags);
void                      pCvreduce(Mat_t* src, Mat_t* dst, int dim, int rtype, int dtype /* default: -1 */);
void                      pCvremap(Mat_t* src, Mat_t* dst, Mat_t* map1, Mat_t* map2, int interpolation, int borderMode /* default: BORDER_CONSTANT */, Scalar_t* borderValue /* default: Scalar() */);
void                      pCvrepeat(Mat_t* src, int ny, int nx, Mat_t* dst);
void                      pCvreprojectImageTo3D(Mat_t* disparity, Mat_t* _3dImage, Mat_t* Q, bool handleMissingValues /* default: false */, int ddepth /* default: -1 */);
void                      pCvresize(Mat_t* src, Mat_t* dst, Size_t* dsize, double fx /* default: 0 */, double fy /* default: 0 */, int interpolation /* default: INTER_LINEAR */);
void                      pCvresizeWindow(string_t* winname, int width, int height);
void                      pCvscaleAdd(Mat_t* src1, double alpha, Mat_t* src2, Mat_t* dst);
void                      pCvsegmentMotion(Mat_t* mhi, Mat_t* segmask, vector_Rect* boundingRects, double timestamp, double segThresh);
void                      pCvsepFilter2D(Mat_t* src, Mat_t* dst, int ddepth, Mat_t* kernelX, Mat_t* kernelY, Point_t* anchor /* default: Point(-1,-1) */, double delta /* default: 0 */, int borderType /* default: BORDER_DEFAULT */);
void                      pCvsetIdentity(Mat_t* mtx, Scalar_t* s /* default: Scalar(1) */);
void                      pCvsetNumThreads(int nthreads);
void                      pCvsetRNGSeed(int seed);
void                      pCvsetTrackbarPos(string_t* trackbarname, string_t* winname, int pos);
void                      pCvsetUseOptimized(bool onoff);
void                      pCvsetWindowProperty(string_t* winname, int prop_id, double prop_value);
bool                      pCvsolve(Mat_t* src1, Mat_t* src2, Mat_t* dst, int flags /* default: DECOMP_LU */);
int                       pCvsolveCubic(Mat_t* coeffs, Mat_t* roots);
bool                      pCvsolvePnP(Mat_t* objectPoints, Mat_t* imagePoints, Mat_t* cameraMatrix, Mat_t* distCoeffs, Mat_t* rvec, Mat_t* tvec, bool useExtrinsicGuess /* default: false */, int flags /* default: ITERATIVE */);
void                      pCvsolvePnPRansac(Mat_t* objectPoints, Mat_t* imagePoints, Mat_t* cameraMatrix, Mat_t* distCoeffs, Mat_t* rvec, Mat_t* tvec, bool useExtrinsicGuess /* default: false */, int iterationsCount /* default: 100 */, float reprojectionError /* default: 8.0 */, int minInliersCount /* default: 100 */, Mat_t* inliers /* default: Mat() */, int flags /* default: ITERATIVE */);
double                    pCvsolvePoly(Mat_t* coeffs, Mat_t* roots, int maxIters /* default: 300 */);
void                      pCvsort(Mat_t* src, Mat_t* dst, int flags);
void                      pCvsortIdx(Mat_t* src, Mat_t* dst, int flags);
void                      pCvsplit(Mat_t* m, vector_Mat* mv);
void                      pCvsqrt(Mat_t* src, Mat_t* dst);
int                       pCvstartWindowThread();
double                    pCvstereoCalibrate(vector_Mat* objectPoints, vector_Mat* imagePoints1, vector_Mat* imagePoints2, Mat_t* cameraMatrix1, Mat_t* distCoeffs1, Mat_t* cameraMatrix2, Mat_t* distCoeffs2, Size_t* imageSize, Mat_t* R, Mat_t* T, Mat_t* E, Mat_t* F, TermCriteria_t* criteria /* default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6) */, int flags /* default: CALIB_FIX_INTRINSIC */);
void                      pCvstereoRectify(Mat_t* cameraMatrix1, Mat_t* distCoeffs1, Mat_t* cameraMatrix2, Mat_t* distCoeffs2, Size_t* imageSize, Mat_t* R, Mat_t* T, Mat_t* R1, Mat_t* R2, Mat_t* P1, Mat_t* P2, Mat_t* Q, int flags /* default: CALIB_ZERO_DISPARITY */, double alpha /* default: -1 */, Size_t* newImageSize /* default: Size() */, Rect_t* validPixROI1 /* default: 0 */, Rect_t* validPixROI2 /* default: 0 */);
bool                      pCvstereoRectifyUncalibrated(Mat_t* points1, Mat_t* points2, Mat_t* F, Size_t* imgSize, Mat_t* H1, Mat_t* H2, double threshold /* default: 5 */);
void                      pCvsubtract(Mat_t* src1, Mat_t* src2, Mat_t* dst, Mat_t* mask /* default: Mat() */, int dtype /* default: -1 */);
Scalar_t*                 pCvsumElems(Mat_t* src);
double                    pCvthreshold(Mat_t* src, Mat_t* dst, double thresh, double maxval, int _type);
Scalar_t*                 pCvtrace(Mat_t* mtx);
void                      pCvtransform(Mat_t* src, Mat_t* dst, Mat_t* m);
void                      pCvtranspose(Mat_t* src, Mat_t* dst);
void                      pCvtriangulatePoints(Mat_t* projMatr1, Mat_t* projMatr2, Mat_t* projPoints1, Mat_t* projPoints2, Mat_t* points4D);
void                      pCvundistort(Mat_t* src, Mat_t* dst, Mat_t* cameraMatrix, Mat_t* distCoeffs, Mat_t* newCameraMatrix /* default: Mat() */);
void                      pCvundistortPoints(Mat_t* src, Mat_t* dst, Mat_t* cameraMatrix, Mat_t* distCoeffs, Mat_t* R /* default: Mat() */, Mat_t* P /* default: Mat() */);
void                      pCvupdateMotionHistory(Mat_t* silhouette, Mat_t* mhi, double timestamp, double duration);
bool                      pCvuseOptimized();
void                      pCvvalidateDisparity(Mat_t* disparity, Mat_t* cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp /* default: 1 */);
void                      pCvvconcat(vector_Mat* src, Mat_t* dst);
int                       pCvwaitKey(int delay /* default: 0 */);
void                      pCvwarpAffine(Mat_t* src, Mat_t* dst, Mat_t* M, Size_t* dsize, int flags /* default: INTER_LINEAR */, int borderMode /* default: BORDER_CONSTANT */, Scalar_t* borderValue /* default: Scalar() */);
void                      pCvwarpPerspective(Mat_t* src, Mat_t* dst, Mat_t* M, Size_t* dsize, int flags /* default: INTER_LINEAR */, int borderMode /* default: BORDER_CONSTANT */, Scalar_t* borderValue /* default: Scalar() */);
void                      pCvwatershed(Mat_t* image, Mat_t* markers);
#ifdef __cplusplus
 }
#endif
