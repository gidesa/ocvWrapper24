Function   pCvBFMatcherCreate(normType: Integer { default: NORM_L2 }; crossCheck: Boolean { default: false }): PCvBFMatcher_t; cdecl;
Procedure  pCvBFMatcherDelete(const wrapper: PCvBFMatcher_t); cdecl;
Function   pCvBOWImgDescriptorExtractorCreate(dextractor: PCvPtr_DescriptorExtractor; dmatcher: PCvPtr_DescriptorMatcher): PCvBOWImgDescriptorExtractor_t; cdecl;
Procedure  pCvBOWImgDescriptorExtractorDelete(const wrapper: PCvBOWImgDescriptorExtractor_t); cdecl;
Function   pCvBOWKMeansTrainerCreate(clusterCount: Integer; termcrit: PCvTermCriteria_t { default: TermCriteria() }; attempts: Integer { default: 3 }; flags: Integer { default: KMEANS_PP_CENTERS }): PCvBOWKMeansTrainer_t; cdecl;
Procedure  pCvBOWKMeansTrainerDelete(const wrapper: PCvBOWKMeansTrainer_t); cdecl;
Function   pCvBRISKCreate(thresh: Integer { default: 30 }; octaves: Integer { default: 3 }; patternScale: Single { default: 1.0f }): PCvBRISK_t; cdecl;
Function   pCvBRISKCreate2(radiusList: PCvvector_float; numberList: PCvvector_int; dMax: Single { default: 5.85f }; dMin: Single { default: 8.2f }; indexChange: PCvvector_int { default: std::vector<int>() }): PCvBRISK_t; cdecl;
Procedure  pCvBRISKDelete(const wrapper: PCvBRISK_t); cdecl;
Function   pCvBackgroundSubtractorMOGCreate(): PCvBackgroundSubtractorMOG_t; cdecl;
Function   pCvBackgroundSubtractorMOGCreate2(history: Integer; nmixtures: Integer; backgroundRatio: Double; noiseSigma: Double { default: 0 }): PCvBackgroundSubtractorMOG_t; cdecl;
Procedure  pCvBackgroundSubtractorMOGDelete(const wrapper: PCvBackgroundSubtractorMOG_t); cdecl;
Function   pCvBackgroundSubtractorMOG2Create(): PCvBackgroundSubtractorMOG2_t; cdecl;
Function   pCvBackgroundSubtractorMOG2Create2(history: Integer; varThreshold: Single; bShadowDetection: Boolean { default: true }): PCvBackgroundSubtractorMOG2_t; cdecl;
Procedure  pCvBackgroundSubtractorMOG2Delete(const wrapper: PCvBackgroundSubtractorMOG2_t); cdecl;
Function   pCvCascadeClassifierCreate(): PCvCascadeClassifier_t; cdecl;
Function   pCvCascadeClassifierCreate2(filename: PCvString_t): PCvCascadeClassifier_t; cdecl;
Procedure  pCvCascadeClassifierDelete(const wrapper: PCvCascadeClassifier_t); cdecl;
Function   pCvCvANN_MLPCreate(): PCvCvANN_MLP_t; cdecl;
Function   pCvCvANN_MLPCreate2(layerSizes: PCvMat_t; activateFunc: Integer { default: CvANN_MLP::SIGMOID_SYM }; fparam1: Double { default: 0 }; fparam2: Double { default: 0 }): PCvCvANN_MLP_t; cdecl;
Procedure  pCvCvANN_MLPDelete(const wrapper: PCvCvANN_MLP_t); cdecl;
Function   pCvCvBoostCreate(): PCvCvBoost_t; cdecl;
Function   pCvCvBoostCreate2(trainData: PCvMat_t; tflag: Integer; responses: PCvMat_t; varIdx: PCvMat_t { default: cv::Mat() }; sampleIdx: PCvMat_t { default: cv::Mat() }; varType: PCvMat_t { default: cv::Mat() }; missingDataMask: PCvMat_t { default: cv::Mat() }; params: PCvCvBoostParams_t { default: CvBoostParams() }): PCvCvBoost_t; cdecl;
Procedure  pCvCvBoostDelete(const wrapper: PCvCvBoost_t); cdecl;
Function   pCvCvDTreeCreate(): PCvCvDTree_t; cdecl;
Procedure  pCvCvDTreeDelete(const wrapper: PCvCvDTree_t); cdecl;
Function   pCvCvERTreesCreate(): PCvCvERTrees_t; cdecl;
Procedure  pCvCvERTreesDelete(const wrapper: PCvCvERTrees_t); cdecl;
Function   pCvCvGBTreesCreate(): PCvCvGBTrees_t; cdecl;
Function   pCvCvGBTreesCreate2(trainData: PCvMat_t; tflag: Integer; responses: PCvMat_t; varIdx: PCvMat_t { default: cv::Mat() }; sampleIdx: PCvMat_t { default: cv::Mat() }; varType: PCvMat_t { default: cv::Mat() }; missingDataMask: PCvMat_t { default: cv::Mat() }; params: PCvCvGBTreesParams_t { default: CvGBTreesParams() }): PCvCvGBTrees_t; cdecl;
Procedure  pCvCvGBTreesDelete(const wrapper: PCvCvGBTrees_t); cdecl;
Function   pCvCvKNearestCreate(): PCvCvKNearest_t; cdecl;
Function   pCvCvKNearestCreate2(trainData: PCvMat_t; responses: PCvMat_t; sampleIdx: PCvMat_t { default: cv::Mat() }; isRegression: Boolean { default: false }; max_k: Integer { default: 32 }): PCvCvKNearest_t; cdecl;
Procedure  pCvCvKNearestDelete(const wrapper: PCvCvKNearest_t); cdecl;
Function   pCvCvNormalBayesClassifierCreate(): PCvCvNormalBayesClassifier_t; cdecl;
Function   pCvCvNormalBayesClassifierCreate2(trainData: PCvMat_t; responses: PCvMat_t; varIdx: PCvMat_t { default: cv::Mat() }; sampleIdx: PCvMat_t { default: cv::Mat() }): PCvCvNormalBayesClassifier_t; cdecl;
Procedure  pCvCvNormalBayesClassifierDelete(const wrapper: PCvCvNormalBayesClassifier_t); cdecl;
Function   pCvCvRTreesCreate(): PCvCvRTrees_t; cdecl;
Procedure  pCvCvRTreesDelete(const wrapper: PCvCvRTrees_t); cdecl;
Function   pCvCvSVMCreate(): PCvCvSVM_t; cdecl;
Function   pCvCvSVMCreate2(trainData: PCvMat_t; responses: PCvMat_t; varIdx: PCvMat_t { default: cv::Mat() }; sampleIdx: PCvMat_t { default: cv::Mat() }; params: PCvCvSVMParams_t { default: CvSVMParams() }): PCvCvSVM_t; cdecl;
Procedure  pCvCvSVMDelete(const wrapper: PCvCvSVM_t); cdecl;
Function   pCvDMatchCreate(): PCvDMatch_t; cdecl;
Function   pCvDMatchCreate2(_queryIdx: Integer; _trainIdx: Integer; _distance: Single): PCvDMatch_t; cdecl;
Function   pCvDMatchCreate3(_queryIdx: Integer; _trainIdx: Integer; _imgIdx: Integer; _distance: Single): PCvDMatch_t; cdecl;
Procedure  pCvDMatchDelete(const wrapper: PCvDMatch_t); cdecl;
Function   pCvEMCreate(nclusters: Integer { default: EM::DEFAULT_NCLUSTERS }; covMatType: Integer { default: EM::COV_MAT_DIAGONAL }; termCrit: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, EM::DEFAULT_MAX_ITERS, FLT_EPSILON) }): PCvEM_t; cdecl;
Procedure  pCvEMDelete(const wrapper: PCvEM_t); cdecl;
Function   pCvFastFeatureDetectorCreate(threshold: Integer { default: 10 }; nonmaxSuppression: Boolean { default: true }): PCvFastFeatureDetector_t; cdecl;
Procedure  pCvFastFeatureDetectorDelete(const wrapper: PCvFastFeatureDetector_t); cdecl;
Function   pCvFileNodeCreate(): PCvFileNode_t; cdecl;
Procedure  pCvFileNodeDelete(const wrapper: PCvFileNode_t); cdecl;
Function   pCvFileStorageCreate(): PCvFileStorage_t; cdecl;
Function   pCvFileStorageCreate2(source: PCvString_t; flags: Integer; encoding: PCvString_t { default: string() }): PCvFileStorage_t; cdecl;
Procedure  pCvFileStorageDelete(const wrapper: PCvFileStorage_t); cdecl;
Function   pCvFlannBasedMatcherCreate(indexParams: PCvPtr_flann_IndexParams { default: new flann::KDTreeIndexParams() }; searchParams: PCvPtr_flann_SearchParams { default: new flann::SearchParams() }): PCvFlannBasedMatcher_t; cdecl;
Procedure  pCvFlannBasedMatcherDelete(const wrapper: PCvFlannBasedMatcher_t); cdecl;
Function   pCvGFTTDetectorCreate(maxCorners: Integer { default: 1000 }; qualityLevel: Double { default: 0.01 }; minDistance: Double { default: 1 }; blockSize: Integer { default: 3 }; useHarrisDetector: Boolean { default: false }; k: Double { default: 0.04 }): PCvGFTTDetector_t; cdecl;
Procedure  pCvGFTTDetectorDelete(const wrapper: PCvGFTTDetector_t); cdecl;
Function   pCvGridAdaptedFeatureDetectorCreate(detector: PCvPtr_FeatureDetector { default: 0 }; maxTotalKeypoints: Integer { default: 1000 }; gridRows: Integer { default: 4 }; gridCols: Integer { default: 4 }): PCvGridAdaptedFeatureDetector_t; cdecl;
Procedure  pCvGridAdaptedFeatureDetectorDelete(const wrapper: PCvGridAdaptedFeatureDetector_t); cdecl;
Function   pCvHOGDescriptorCreate(): PCvHOGDescriptor_t; cdecl;
Function   pCvHOGDescriptorCreate2(_winSize: PCvSize_t; _blockSize: PCvSize_t; _blockStride: PCvSize_t; _cellSize: PCvSize_t; _nbins: Integer; _derivAperture: Integer { default: 1 }; _winSigma: Double { default: -1 }; _histogramNormType: Integer { default: HOGDescriptor::L2Hys }; _L2HysThreshold: Double { default: 0.2 }; _gammaCorrection: Boolean { default: false }; _nlevels: Integer { default: HOGDescriptor::DEFAULT_NLEVELS }): PCvHOGDescriptor_t; cdecl;
Function   pCvHOGDescriptorCreate3(filename: PCvString_t): PCvHOGDescriptor_t; cdecl;
Procedure  pCvHOGDescriptorDelete(const wrapper: PCvHOGDescriptor_t); cdecl;
Function   pCvflann_IndexCreate(): PCvflann_Index_t; cdecl;
Function   pCvflann_IndexCreate2(features: PCvMat_t; params: PCvIndexParams_t; distType: Integer { default: cvflann::FLANN_DIST_L2 }): PCvflann_Index_t; cdecl;
Procedure  pCvflann_IndexDelete(const wrapper: PCvflann_Index_t); cdecl;
Function   pCvKDTreeCreate(): PCvKDTree_t; cdecl;
Function   pCvKDTreeCreate2(points: PCvMat_t; copyAndReorderPoints: Boolean { default: false }): PCvKDTree_t; cdecl;
Function   pCvKDTreeCreate3(points: PCvMat_t; _labels: PCvMat_t; copyAndReorderPoints: Boolean { default: false }): PCvKDTree_t; cdecl;
Procedure  pCvKDTreeDelete(const wrapper: PCvKDTree_t); cdecl;
Function   pCvKalmanFilterCreate(): PCvKalmanFilter_t; cdecl;
Function   pCvKalmanFilterCreate2(dynamParams: Integer; measureParams: Integer; controlParams: Integer { default: 0 }; _type: Integer { default: CV_32F }): PCvKalmanFilter_t; cdecl;
Procedure  pCvKalmanFilterDelete(const wrapper: PCvKalmanFilter_t); cdecl;
Function   pCvKeyPointCreate(): PCvKeyPoint_t; cdecl;
Function   pCvKeyPointCreate2(x: Single; y: Single; _size: Single; _angle: Single { default: -1 }; _response: Single { default: 0 }; _octave: Integer { default: 0 }; _class_id: Integer { default: -1 }): PCvKeyPoint_t; cdecl;
Procedure  pCvKeyPointDelete(const wrapper: PCvKeyPoint_t); cdecl;
Function   pCvMSERCreate(_delta: Integer { default: 5 }; _min_area: Integer { default: 60 }; _max_area: Integer { default: 14400 }; _max_variation: Double { default: 0.25 }; _min_diversity: Double { default: .2 }; _max_evolution: Integer { default: 200 }; _area_threshold: Double { default: 1.01 }; _min_margin: Double { default: 0.003 }; _edge_blur_size: Integer { default: 5 }): PCvMSER_t; cdecl;
Procedure  pCvMSERDelete(const wrapper: PCvMSER_t); cdecl;
Function   pCvORBCreate(nfeatures: Integer { default: 500 }; scaleFactor: Single { default: 1.2f }; nlevels: Integer { default: 8 }; edgeThreshold: Integer { default: 31 }; firstLevel: Integer { default: 0 }; WTA_K: Integer { default: 2 }; scoreType: Integer { default: ORB::HARRIS_SCORE }; patchSize: Integer { default: 31 }): PCvORB_t; cdecl;
Procedure  pCvORBDelete(const wrapper: PCvORB_t); cdecl;
Function   pCvSimpleBlobDetector_ParamsCreate(): PCvSimpleBlobDetector_Params_t; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsDelete(const wrapper: PCvSimpleBlobDetector_Params_t); cdecl;
Function   pCvPyramidAdaptedFeatureDetectorCreate(detector: PCvPtr_FeatureDetector; maxLevel: Integer { default: 2 }): PCvPyramidAdaptedFeatureDetector_t; cdecl;
Procedure  pCvPyramidAdaptedFeatureDetectorDelete(const wrapper: PCvPyramidAdaptedFeatureDetector_t); cdecl;
Function   pCvSIFTCreate(nfeatures: Integer { default: 0 }; nOctaveLayers: Integer { default: 3 }; contrastThreshold: Double { default: 0.04 }; edgeThreshold: Double { default: 10 }; sigma: Double { default: 1.6 }): PCvSIFT_t; cdecl;
Procedure  pCvSIFTDelete(const wrapper: PCvSIFT_t); cdecl;
Function   pCvSURFCreate(): PCvSURF_t; cdecl;
Function   pCvSURFCreate2(hessianThreshold: Double; nOctaves: Integer { default: 4 }; nOctaveLayers: Integer { default: 2 }; extended: Boolean { default: true }; upright: Boolean { default: false }): PCvSURF_t; cdecl;
Procedure  pCvSURFDelete(const wrapper: PCvSURF_t); cdecl;
Function   pCvSimpleBlobDetectorCreate(parameters: PCvSimpleBlobDetector_Params_t { default: SimpleBlobDetector::Params() }): PCvSimpleBlobDetector_t; cdecl;
Procedure  pCvSimpleBlobDetectorDelete(const wrapper: PCvSimpleBlobDetector_t); cdecl;
Function   pCvStarDetectorCreate(_maxSize: Integer { default: 45 }; _responseThreshold: Integer { default: 30 }; _lineThresholdProjected: Integer { default: 10 }; _lineThresholdBinarized: Integer { default: 8 }; _suppressNonmaxSize: Integer { default: 5 }): PCvStarDetector_t; cdecl;
Procedure  pCvStarDetectorDelete(const wrapper: PCvStarDetector_t); cdecl;
Function   pCvStereoBMCreate(): PCvStereoBM_t; cdecl;
Function   pCvStereoBMCreate2(preset: Integer; ndisparities: Integer { default: 0 }; SADWindowSize: Integer { default: 21 }): PCvStereoBM_t; cdecl;
Procedure  pCvStereoBMDelete(const wrapper: PCvStereoBM_t); cdecl;
Function   pCvStereoSGBMCreate(): PCvStereoSGBM_t; cdecl;
Function   pCvStereoSGBMCreate2(minDisparity: Integer; numDisparities: Integer; SADWindowSize: Integer; P1: Integer { default: 0 }; P2: Integer { default: 0 }; disp12MaxDiff: Integer { default: 0 }; preFilterCap: Integer { default: 0 }; uniquenessRatio: Integer { default: 0 }; speckleWindowSize: Integer { default: 0 }; speckleRange: Integer { default: 0 }; fullDP: Boolean { default: false }): PCvStereoSGBM_t; cdecl;
Procedure  pCvStereoSGBMDelete(const wrapper: PCvStereoSGBM_t); cdecl;
Function   pCvStereoVarCreate(): PCvStereoVar_t; cdecl;
Function   pCvStereoVarCreate2(levels: Integer; pyrScale: Double; nIt: Integer; minDisp: Integer; maxDisp: Integer; poly_n: Integer; poly_sigma: Double; fi: Single; lambda: Single; penalization: Integer; cycle: Integer; flags: Integer): PCvStereoVar_t; cdecl;
Procedure  pCvStereoVarDelete(const wrapper: PCvStereoVar_t); cdecl;
Function   pCvSubdiv2DCreate(): PCvSubdiv2D_t; cdecl;
Function   pCvSubdiv2DCreate2(rect: PCvRect_t): PCvSubdiv2D_t; cdecl;
Procedure  pCvSubdiv2DDelete(const wrapper: PCvSubdiv2D_t); cdecl;
Function   pCvVideoCaptureCreate(): PCvVideoCapture_t; cdecl;
Function   pCvVideoCaptureCreate2(filename: PCvString_t): PCvVideoCapture_t; cdecl;
Function   pCvVideoCaptureCreate3(device: Integer): PCvVideoCapture_t; cdecl;
Procedure  pCvVideoCaptureDelete(const wrapper: PCvVideoCapture_t); cdecl;
Function   pCvVideoWriterCreate(): PCvVideoWriter_t; cdecl;
Function   pCvVideoWriterCreate2(filename: PCvString_t; fourcc: Integer; fps: Double; frameSize: PCvSize_t; isColor: Boolean { default: true }): PCvVideoWriter_t; cdecl;
Procedure  pCvVideoWriterDelete(const wrapper: PCvVideoWriter_t); cdecl;
Function   pCvAlgorithmgetAlgorithm(const wrapper: PCvAlgorithm_t; name: PCvString_t): PCvPtr_Algorithm; cdecl;
Function   pCvAlgorithmgetBool(const wrapper: PCvAlgorithm_t; name: PCvString_t): Boolean; cdecl;
Function   pCvAlgorithmgetDouble(const wrapper: PCvAlgorithm_t; name: PCvString_t): Double; cdecl;
Function   pCvAlgorithmgetInt(const wrapper: PCvAlgorithm_t; name: PCvString_t): Integer; cdecl;
Function   pCvAlgorithmgetMat(const wrapper: PCvAlgorithm_t; name: PCvString_t): PCvMat_t; cdecl;
Function   pCvAlgorithmgetMatVector(const wrapper: PCvAlgorithm_t; name: PCvString_t): PCvvector_Mat; cdecl;
Procedure  pCvAlgorithmgetParams(const wrapper: PCvAlgorithm_t; names: PCvvector_string); cdecl;
Function   pCvAlgorithmgetString(const wrapper: PCvAlgorithm_t; name: PCvString_t): PCvString_t; cdecl;
Function   pCvAlgorithmparamHelp(const wrapper: PCvAlgorithm_t; name: PCvString_t): PCvString_t; cdecl;
Function   pCvAlgorithmparamType(const wrapper: PCvAlgorithm_t; name: PCvString_t): Integer; cdecl;
Procedure  pCvAlgorithmsetAlgorithm(const wrapper: PCvAlgorithm_t; name: PCvString_t; value: PCvPtr_Algorithm); cdecl;
Procedure  pCvAlgorithmsetBool(const wrapper: PCvAlgorithm_t; name: PCvString_t; value: Boolean); cdecl;
Procedure  pCvAlgorithmsetDouble(const wrapper: PCvAlgorithm_t; name: PCvString_t; value: Double); cdecl;
Procedure  pCvAlgorithmsetInt(const wrapper: PCvAlgorithm_t; name: PCvString_t; value: Integer); cdecl;
Procedure  pCvAlgorithmsetMat(const wrapper: PCvAlgorithm_t; name: PCvString_t; value: PCvMat_t); cdecl;
Procedure  pCvAlgorithmsetMatVector(const wrapper: PCvAlgorithm_t; name: PCvString_t; value: PCvvector_Mat); cdecl;
Procedure  pCvAlgorithmsetString(const wrapper: PCvAlgorithm_t; name: PCvString_t; value: PCvString_t); cdecl;
Procedure  pCvBFMatcheradd(const wrapper: PCvBFMatcher_t; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvBFMatcherclear(const wrapper: PCvBFMatcher_t); cdecl;
Function   pCvBFMatcherempty(const wrapper: PCvBFMatcher_t): Boolean; cdecl;
Function   pCvBFMatchergetTrainDescriptors(const wrapper: PCvBFMatcher_t): PCvvector_Mat; cdecl;
Procedure  pCvBFMatcherknnMatch(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvMat_t; trainDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; k: Integer; mask: PCvMat_t { default: Mat() }; compactResult: Boolean { default: false }); cdecl;
Procedure  pCvBFMatcherknnMatch2(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; k: Integer; masks: PCvvector_Mat { default: vector<Mat>() }; compactResult: Boolean { default: false }); cdecl;
Procedure  pCvBFMatchermatch(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvMat_t; trainDescriptors: PCvMat_t; matches: PCvvector_DMatch; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvBFMatchermatch2(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvMat_t; matches: PCvvector_DMatch; masks: PCvvector_Mat { default: vector<Mat>() }); cdecl;
Procedure  pCvBFMatchertrain(const wrapper: PCvBFMatcher_t); cdecl;
Procedure  pCvBOWImgDescriptorExtractorcompute(const wrapper: PCvBOWImgDescriptorExtractor_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; imgDescriptor: PCvMat_t); cdecl;
Function   pCvBOWImgDescriptorExtractordescriptorSize(const wrapper: PCvBOWImgDescriptorExtractor_t): Integer; cdecl;
Function   pCvBOWImgDescriptorExtractordescriptorType(const wrapper: PCvBOWImgDescriptorExtractor_t): Integer; cdecl;
Function   pCvBOWImgDescriptorExtractorgetVocabulary(const wrapper: PCvBOWImgDescriptorExtractor_t): PCvMat_t; cdecl;
Procedure  pCvBOWImgDescriptorExtractorsetVocabulary(const wrapper: PCvBOWImgDescriptorExtractor_t; vocabulary: PCvMat_t); cdecl;
Procedure  pCvBOWKMeansTraineradd(const wrapper: PCvBOWKMeansTrainer_t; descriptors: PCvMat_t); cdecl;
Procedure  pCvBOWKMeansTrainerclear(const wrapper: PCvBOWKMeansTrainer_t); cdecl;
Function   pCvBOWKMeansTrainercluster(const wrapper: PCvBOWKMeansTrainer_t): PCvMat_t; cdecl;
Function   pCvBOWKMeansTrainercluster2(const wrapper: PCvBOWKMeansTrainer_t; descriptors: PCvMat_t): PCvMat_t; cdecl;
Function   pCvBOWKMeansTrainerdescripotorsCount(const wrapper: PCvBOWKMeansTrainer_t): Integer; cdecl;
Function   pCvBOWKMeansTrainergetDescriptors(const wrapper: PCvBOWKMeansTrainer_t): PCvvector_Mat; cdecl;
Procedure  pCvBOWTraineradd(const wrapper: PCvBOWTrainer_t; descriptors: PCvMat_t); cdecl;
Procedure  pCvBOWTrainerclear(const wrapper: PCvBOWTrainer_t); cdecl;
Function   pCvBOWTrainerdescripotorsCount(const wrapper: PCvBOWTrainer_t): Integer; cdecl;
Function   pCvBOWTrainergetDescriptors(const wrapper: PCvBOWTrainer_t): PCvvector_Mat; cdecl;
Procedure  pCvBRISKcompute(const wrapper: PCvBRISK_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Procedure  pCvBRISKdetectAndCompute(const wrapper: PCvBRISK_t; image: PCvMat_t; mask: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; useProvidedKeypoints: Boolean { default: false }); cdecl;
Procedure  pCvBRISKgenerateKernel(const wrapper: PCvBRISK_t; radiusList: PCvvector_float; numberList: PCvvector_int; dMax: Single { default: 5.85f }; dMin: Single { default: 8.2f }; indexChange: PCvvector_int { default: std::vector<int>() }); cdecl;
Procedure  pCvBackgroundSubtractorapply(const wrapper: PCvBackgroundSubtractor_t; image: PCvMat_t; fgmask: PCvMat_t; learningRate: Double { default: 0 }); cdecl;
Procedure  pCvBackgroundSubtractorMOGapply(const wrapper: PCvBackgroundSubtractorMOG_t; image: PCvMat_t; fgmask: PCvMat_t; learningRate: Double { default: 0 }); cdecl;
Procedure  pCvBackgroundSubtractorMOG2apply(const wrapper: PCvBackgroundSubtractorMOG2_t; image: PCvMat_t; fgmask: PCvMat_t; learningRate: Double { default: 0 }); cdecl;
Procedure  pCvCLAHEapply(const wrapper: PCvCLAHE_t; src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvCLAHEsetClipLimit(const wrapper: PCvCLAHE_t; clipLimit: Double); cdecl;
Procedure  pCvCLAHEsetTilesGridSize(const wrapper: PCvCLAHE_t; tileGridSize: PCvSize_t); cdecl;
Procedure  pCvCascadeClassifierdetectMultiScale(const wrapper: PCvCascadeClassifier_t; image: PCvMat_t; objects: PCvvector_Rect; scaleFactor: Double { default: 1.1 }; minNeighbors: Integer { default: 3 }; flags: Integer { default: 0 }; minSize: PCvSize_t { default: Size() }; maxSize: PCvSize_t { default: Size() }); cdecl;
Procedure  pCvCascadeClassifierdetectMultiScale2(const wrapper: PCvCascadeClassifier_t; image: PCvMat_t; objects: PCvvector_Rect; rejectLevels: PCvvector_int; levelWeights: PCvvector_double; scaleFactor: Double { default: 1.1 }; minNeighbors: Integer { default: 3 }; flags: Integer { default: 0 }; minSize: PCvSize_t { default: Size() }; maxSize: PCvSize_t { default: Size() }; outputRejectLevels: Boolean { default: false }); cdecl;
Function   pCvCascadeClassifierempty(const wrapper: PCvCascadeClassifier_t): Boolean; cdecl;
Function   pCvCascadeClassifierload(const wrapper: PCvCascadeClassifier_t; filename: PCvString_t): Boolean; cdecl;
Procedure  pCvCvANN_MLPclear(const wrapper: PCvCvANN_MLP_t); cdecl;
Procedure  pCvCvANN_MLP_create(const wrapper: PCvCvANN_MLP_t; layerSizes: PCvMat_t; activateFunc: Integer { default: CvANN_MLP::SIGMOID_SYM }; fparam1: Double { default: 0 }; fparam2: Double { default: 0 }); cdecl;
Procedure  pCvCvANN_MLPload(const wrapper: PCvCvANN_MLP_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvANN_MLPpredict(const wrapper: PCvCvANN_MLP_t; inputs: PCvMat_t; outputs: PCvMat_t): Single; cdecl;
Procedure  pCvCvANN_MLPsave(const wrapper: PCvCvANN_MLP_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvANN_MLPtrain(const wrapper: PCvCvANN_MLP_t; inputs: PCvMat_t; outputs: PCvMat_t; sampleWeights: PCvMat_t; sampleIdx: PCvMat_t { default: cv::Mat() }; params: PCvCvANN_MLP_TrainParams_t { default: CvANN_MLP_TrainParams() }; flags: Integer { default: 0 }): Integer; cdecl;
Function   pCvCvANN_MLP_TrainParamsGet_bp_dw_scale(const wrapper: PCvCvANN_MLP_TrainParams_t): Double; cdecl;
Procedure  pCvCvANN_MLP_TrainParamsSet_bp_dw_scale(const wrapper: PCvCvANN_MLP_TrainParams_t; val: Double); cdecl;
Function   pCvCvANN_MLP_TrainParamsGet_bp_moment_scale(const wrapper: PCvCvANN_MLP_TrainParams_t): Double; cdecl;
Procedure  pCvCvANN_MLP_TrainParamsSet_bp_moment_scale(const wrapper: PCvCvANN_MLP_TrainParams_t; val: Double); cdecl;
Function   pCvCvANN_MLP_TrainParamsGet_rp_dw0(const wrapper: PCvCvANN_MLP_TrainParams_t): Double; cdecl;
Procedure  pCvCvANN_MLP_TrainParamsSet_rp_dw0(const wrapper: PCvCvANN_MLP_TrainParams_t; val: Double); cdecl;
Function   pCvCvANN_MLP_TrainParamsGet_rp_dw_max(const wrapper: PCvCvANN_MLP_TrainParams_t): Double; cdecl;
Procedure  pCvCvANN_MLP_TrainParamsSet_rp_dw_max(const wrapper: PCvCvANN_MLP_TrainParams_t; val: Double); cdecl;
Function   pCvCvANN_MLP_TrainParamsGet_rp_dw_min(const wrapper: PCvCvANN_MLP_TrainParams_t): Double; cdecl;
Procedure  pCvCvANN_MLP_TrainParamsSet_rp_dw_min(const wrapper: PCvCvANN_MLP_TrainParams_t; val: Double); cdecl;
Function   pCvCvANN_MLP_TrainParamsGet_rp_dw_minus(const wrapper: PCvCvANN_MLP_TrainParams_t): Double; cdecl;
Procedure  pCvCvANN_MLP_TrainParamsSet_rp_dw_minus(const wrapper: PCvCvANN_MLP_TrainParams_t; val: Double); cdecl;
Function   pCvCvANN_MLP_TrainParamsGet_rp_dw_plus(const wrapper: PCvCvANN_MLP_TrainParams_t): Double; cdecl;
Procedure  pCvCvANN_MLP_TrainParamsSet_rp_dw_plus(const wrapper: PCvCvANN_MLP_TrainParams_t; val: Double); cdecl;
Function   pCvCvANN_MLP_TrainParamsGet_term_crit(const wrapper: PCvCvANN_MLP_TrainParams_t): PCvCvTermCriteria_t; cdecl;
Procedure  pCvCvANN_MLP_TrainParamsSet_term_crit(const wrapper: PCvCvANN_MLP_TrainParams_t; val: PCvCvTermCriteria_t); cdecl;
Function   pCvCvANN_MLP_TrainParamsGet_train_method(const wrapper: PCvCvANN_MLP_TrainParams_t): Integer; cdecl;
Procedure  pCvCvANN_MLP_TrainParamsSet_train_method(const wrapper: PCvCvANN_MLP_TrainParams_t; val: Integer); cdecl;
Procedure  pCvCvBoostclear(const wrapper: PCvCvBoost_t); cdecl;
Procedure  pCvCvBoostload(const wrapper: PCvCvBoost_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvBoostpredict(const wrapper: PCvCvBoost_t; sample: PCvMat_t; missing: PCvMat_t { default: cv::Mat() }; slice: PCvRange_t { default: cv::Range::all() }; rawMode: Boolean { default: false }; returnSum: Boolean { default: false }): Single; cdecl;
Procedure  pCvCvBoostprune(const wrapper: PCvCvBoost_t; slice: PCvCvSlice_t); cdecl;
Procedure  pCvCvBoostsave(const wrapper: PCvCvBoost_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvBoosttrain(const wrapper: PCvCvBoost_t; trainData: PCvMat_t; tflag: Integer; responses: PCvMat_t; varIdx: PCvMat_t { default: cv::Mat() }; sampleIdx: PCvMat_t { default: cv::Mat() }; varType: PCvMat_t { default: cv::Mat() }; missingDataMask: PCvMat_t { default: cv::Mat() }; params: PCvCvBoostParams_t { default: CvBoostParams() }; update: Boolean { default: false }): Boolean; cdecl;
Function   pCvCvBoostParamsGet_boost_type(const wrapper: PCvCvBoostParams_t): Integer; cdecl;
Procedure  pCvCvBoostParamsSet_boost_type(const wrapper: PCvCvBoostParams_t; val: Integer); cdecl;
Function   pCvCvBoostParamsGet_split_criteria(const wrapper: PCvCvBoostParams_t): Integer; cdecl;
Procedure  pCvCvBoostParamsSet_split_criteria(const wrapper: PCvCvBoostParams_t; val: Integer); cdecl;
Function   pCvCvBoostParamsGet_weak_count(const wrapper: PCvCvBoostParams_t): Integer; cdecl;
Procedure  pCvCvBoostParamsSet_weak_count(const wrapper: PCvCvBoostParams_t; val: Integer); cdecl;
Function   pCvCvBoostParamsGet_weight_trim_rate(const wrapper: PCvCvBoostParams_t): Double; cdecl;
Procedure  pCvCvBoostParamsSet_weight_trim_rate(const wrapper: PCvCvBoostParams_t; val: Double); cdecl;
Procedure  pCvCvDTreeclear(const wrapper: PCvCvDTree_t); cdecl;
Function   pCvCvDTreegetVarImportance(const wrapper: PCvCvDTree_t): PCvMat_t; cdecl;
Procedure  pCvCvDTreeload(const wrapper: PCvCvDTree_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvDTreepredict(const wrapper: PCvCvDTree_t; sample: PCvMat_t; missingDataMask: PCvMat_t { default: cv::Mat() }; preprocessedInput: Boolean { default: false }): PCvCvDTreeNode_t; cdecl;
Procedure  pCvCvDTreesave(const wrapper: PCvCvDTree_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvDTreetrain(const wrapper: PCvCvDTree_t; trainData: PCvMat_t; tflag: Integer; responses: PCvMat_t; varIdx: PCvMat_t { default: cv::Mat() }; sampleIdx: PCvMat_t { default: cv::Mat() }; varType: PCvMat_t { default: cv::Mat() }; missingDataMask: PCvMat_t { default: cv::Mat() }; params: PCvCvDTreeParams_t { default: CvDTreeParams() }): Boolean; cdecl;
Function   pCvCvDTreeParamsGet_cv_folds(const wrapper: PCvCvDTreeParams_t): Integer; cdecl;
Procedure  pCvCvDTreeParamsSet_cv_folds(const wrapper: PCvCvDTreeParams_t; val: Integer); cdecl;
Function   pCvCvDTreeParamsGet_max_categories(const wrapper: PCvCvDTreeParams_t): Integer; cdecl;
Procedure  pCvCvDTreeParamsSet_max_categories(const wrapper: PCvCvDTreeParams_t; val: Integer); cdecl;
Function   pCvCvDTreeParamsGet_max_depth(const wrapper: PCvCvDTreeParams_t): Integer; cdecl;
Procedure  pCvCvDTreeParamsSet_max_depth(const wrapper: PCvCvDTreeParams_t; val: Integer); cdecl;
Function   pCvCvDTreeParamsGet_min_sample_count(const wrapper: PCvCvDTreeParams_t): Integer; cdecl;
Procedure  pCvCvDTreeParamsSet_min_sample_count(const wrapper: PCvCvDTreeParams_t; val: Integer); cdecl;
Function   pCvCvDTreeParamsGet_regression_accuracy(const wrapper: PCvCvDTreeParams_t): Single; cdecl;
Procedure  pCvCvDTreeParamsSet_regression_accuracy(const wrapper: PCvCvDTreeParams_t; val: Single); cdecl;
Function   pCvCvDTreeParamsGet_truncate_pruned_tree(const wrapper: PCvCvDTreeParams_t): Boolean; cdecl;
Procedure  pCvCvDTreeParamsSet_truncate_pruned_tree(const wrapper: PCvCvDTreeParams_t; val: Boolean); cdecl;
Function   pCvCvDTreeParamsGet_use_1se_rule(const wrapper: PCvCvDTreeParams_t): Boolean; cdecl;
Procedure  pCvCvDTreeParamsSet_use_1se_rule(const wrapper: PCvCvDTreeParams_t; val: Boolean); cdecl;
Function   pCvCvDTreeParamsGet_use_surrogates(const wrapper: PCvCvDTreeParams_t): Boolean; cdecl;
Procedure  pCvCvDTreeParamsSet_use_surrogates(const wrapper: PCvCvDTreeParams_t; val: Boolean); cdecl;
Procedure  pCvCvERTreesclear(const wrapper: PCvCvERTrees_t); cdecl;
Function   pCvCvERTreesgetVarImportance(const wrapper: PCvCvERTrees_t): PCvMat_t; cdecl;
Function   pCvCvERTreespredict(const wrapper: PCvCvERTrees_t; sample: PCvMat_t; missing: PCvMat_t { default: cv::Mat() }): Single; cdecl;
Function   pCvCvERTreespredict_prob(const wrapper: PCvCvERTrees_t; sample: PCvMat_t; missing: PCvMat_t { default: cv::Mat() }): Single; cdecl;
Function   pCvCvERTreestrain(const wrapper: PCvCvERTrees_t; trainData: PCvMat_t; tflag: Integer; responses: PCvMat_t; varIdx: PCvMat_t { default: cv::Mat() }; sampleIdx: PCvMat_t { default: cv::Mat() }; varType: PCvMat_t { default: cv::Mat() }; missingDataMask: PCvMat_t { default: cv::Mat() }; params: PCvCvRTParams_t { default: CvRTParams() }): Boolean; cdecl;
Procedure  pCvCvGBTreesclear(const wrapper: PCvCvGBTrees_t); cdecl;
Procedure  pCvCvGBTreesload(const wrapper: PCvCvGBTrees_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvGBTreespredict(const wrapper: PCvCvGBTrees_t; sample: PCvMat_t; missing: PCvMat_t { default: cv::Mat() }; slice: PCvRange_t { default: cv::Range::all() }; k: Integer { default: -1 }): Single; cdecl;
Procedure  pCvCvGBTreessave(const wrapper: PCvCvGBTrees_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvGBTreestrain(const wrapper: PCvCvGBTrees_t; trainData: PCvMat_t; tflag: Integer; responses: PCvMat_t; varIdx: PCvMat_t { default: cv::Mat() }; sampleIdx: PCvMat_t { default: cv::Mat() }; varType: PCvMat_t { default: cv::Mat() }; missingDataMask: PCvMat_t { default: cv::Mat() }; params: PCvCvGBTreesParams_t { default: CvGBTreesParams() }; update: Boolean { default: false }): Boolean; cdecl;
Function   pCvCvGBTreesParamsGet_loss_function_type(const wrapper: PCvCvGBTreesParams_t): Integer; cdecl;
Procedure  pCvCvGBTreesParamsSet_loss_function_type(const wrapper: PCvCvGBTreesParams_t; val: Integer); cdecl;
Function   pCvCvGBTreesParamsGet_shrinkage(const wrapper: PCvCvGBTreesParams_t): Single; cdecl;
Procedure  pCvCvGBTreesParamsSet_shrinkage(const wrapper: PCvCvGBTreesParams_t; val: Single); cdecl;
Function   pCvCvGBTreesParamsGet_subsample_portion(const wrapper: PCvCvGBTreesParams_t): Single; cdecl;
Procedure  pCvCvGBTreesParamsSet_subsample_portion(const wrapper: PCvCvGBTreesParams_t; val: Single); cdecl;
Function   pCvCvGBTreesParamsGet_weak_count(const wrapper: PCvCvGBTreesParams_t): Integer; cdecl;
Procedure  pCvCvGBTreesParamsSet_weak_count(const wrapper: PCvCvGBTreesParams_t; val: Integer); cdecl;
Function   pCvCvKNearestfind_nearest(const wrapper: PCvCvKNearest_t; samples: PCvMat_t; k: Integer; results: PCvMat_t; neighborResponses: PCvMat_t; dists: PCvMat_t): Single; cdecl;
Procedure  pCvCvKNearestload(const wrapper: PCvCvKNearest_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Procedure  pCvCvKNearestsave(const wrapper: PCvCvKNearest_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvKNearesttrain(const wrapper: PCvCvKNearest_t; trainData: PCvMat_t; responses: PCvMat_t; sampleIdx: PCvMat_t { default: cv::Mat() }; isRegression: Boolean { default: false }; maxK: Integer { default: 32 }; updateBase: Boolean { default: false }): Boolean; cdecl;
Procedure  pCvCvNormalBayesClassifierclear(const wrapper: PCvCvNormalBayesClassifier_t); cdecl;
Procedure  pCvCvNormalBayesClassifierload(const wrapper: PCvCvNormalBayesClassifier_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvNormalBayesClassifierpredict(const wrapper: PCvCvNormalBayesClassifier_t; samples: PCvMat_t; results: PCvMat_t { default: 0 }): Single; cdecl;
Procedure  pCvCvNormalBayesClassifiersave(const wrapper: PCvCvNormalBayesClassifier_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvNormalBayesClassifiertrain(const wrapper: PCvCvNormalBayesClassifier_t; trainData: PCvMat_t; responses: PCvMat_t; varIdx: PCvMat_t { default: cv::Mat() }; sampleIdx: PCvMat_t { default: cv::Mat() }; update: Boolean { default: false }): Boolean; cdecl;
Function   pCvCvParamGridGet_max_val(const wrapper: PCvCvParamGrid_t): Double; cdecl;
Procedure  pCvCvParamGridSet_max_val(const wrapper: PCvCvParamGrid_t; val: Double); cdecl;
Function   pCvCvParamGridGet_min_val(const wrapper: PCvCvParamGrid_t): Double; cdecl;
Procedure  pCvCvParamGridSet_min_val(const wrapper: PCvCvParamGrid_t; val: Double); cdecl;
Function   pCvCvParamGridGet_step(const wrapper: PCvCvParamGrid_t): Double; cdecl;
Procedure  pCvCvParamGridSet_step(const wrapper: PCvCvParamGrid_t; val: Double); cdecl;
Function   pCvCvRTParamsGet_calc_var_importance(const wrapper: PCvCvRTParams_t): Boolean; cdecl;
Procedure  pCvCvRTParamsSet_calc_var_importance(const wrapper: PCvCvRTParams_t; val: Boolean); cdecl;
Function   pCvCvRTParamsGet_nactive_vars(const wrapper: PCvCvRTParams_t): Integer; cdecl;
Procedure  pCvCvRTParamsSet_nactive_vars(const wrapper: PCvCvRTParams_t; val: Integer); cdecl;
Function   pCvCvRTParamsGet_term_crit(const wrapper: PCvCvRTParams_t): PCvCvTermCriteria_t; cdecl;
Procedure  pCvCvRTParamsSet_term_crit(const wrapper: PCvCvRTParams_t; val: PCvCvTermCriteria_t); cdecl;
Procedure  pCvCvRTreesclear(const wrapper: PCvCvRTrees_t); cdecl;
Function   pCvCvRTreesgetVarImportance(const wrapper: PCvCvRTrees_t): PCvMat_t; cdecl;
Procedure  pCvCvRTreesload(const wrapper: PCvCvRTrees_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvRTreespredict(const wrapper: PCvCvRTrees_t; sample: PCvMat_t; missing: PCvMat_t { default: cv::Mat() }): Single; cdecl;
Function   pCvCvRTreespredict_prob(const wrapper: PCvCvRTrees_t; sample: PCvMat_t; missing: PCvMat_t { default: cv::Mat() }): Single; cdecl;
Procedure  pCvCvRTreessave(const wrapper: PCvCvRTrees_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvRTreestrain(const wrapper: PCvCvRTrees_t; trainData: PCvMat_t; tflag: Integer; responses: PCvMat_t; varIdx: PCvMat_t { default: cv::Mat() }; sampleIdx: PCvMat_t { default: cv::Mat() }; varType: PCvMat_t { default: cv::Mat() }; missingDataMask: PCvMat_t { default: cv::Mat() }; params: PCvCvRTParams_t { default: CvRTParams() }): Boolean; cdecl;
Procedure  pCvCvSVMclear(const wrapper: PCvCvSVM_t); cdecl;
Function   pCvCvSVMget_support_vector_count(const wrapper: PCvCvSVM_t): Integer; cdecl;
Function   pCvCvSVMget_var_count(const wrapper: PCvCvSVM_t): Integer; cdecl;
Procedure  pCvCvSVMload(const wrapper: PCvCvSVM_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvSVMpredict(const wrapper: PCvCvSVM_t; sample: PCvMat_t; returnDFVal: Boolean { default: false }): Single; cdecl;
Procedure  pCvCvSVMpredict_all(const wrapper: PCvCvSVM_t; samples: PCvMat_t; results: PCvMat_t); cdecl;
Procedure  pCvCvSVMsave(const wrapper: PCvCvSVM_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvCvSVMtrain(const wrapper: PCvCvSVM_t; trainData: PCvMat_t; responses: PCvMat_t; varIdx: PCvMat_t { default: cv::Mat() }; sampleIdx: PCvMat_t { default: cv::Mat() }; params: PCvCvSVMParams_t { default: CvSVMParams() }): Boolean; cdecl;
Function   pCvCvSVMtrain_auto(const wrapper: PCvCvSVM_t; trainData: PCvMat_t; responses: PCvMat_t; varIdx: PCvMat_t; sampleIdx: PCvMat_t; params: PCvCvSVMParams_t; k_fold: Integer { default: 10 }; Cgrid: PCvCvParamGrid_t { default: CvSVM::get_default_grid(CvSVM::C) }; gammaGrid: PCvCvParamGrid_t { default: CvSVM::get_default_grid(CvSVM::GAMMA) }; pGrid: PCvCvParamGrid_t { default: CvSVM::get_default_grid(CvSVM::P) }; nuGrid: PCvCvParamGrid_t { default: CvSVM::get_default_grid(CvSVM::NU) }; coeffGrid: PCvCvParamGrid_t { default: CvSVM::get_default_grid(CvSVM::COEF) }; degreeGrid: PCvCvParamGrid_t { default: CvSVM::get_default_grid(CvSVM::DEGREE) }; balanced: Boolean { default: false }): Boolean; cdecl;
Function   pCvCvSVMParamsGet_C(const wrapper: PCvCvSVMParams_t): Double; cdecl;
Procedure  pCvCvSVMParamsSet_C(const wrapper: PCvCvSVMParams_t; val: Double); cdecl;
Function   pCvCvSVMParamsGet_coef0(const wrapper: PCvCvSVMParams_t): Double; cdecl;
Procedure  pCvCvSVMParamsSet_coef0(const wrapper: PCvCvSVMParams_t; val: Double); cdecl;
Function   pCvCvSVMParamsGet_degree(const wrapper: PCvCvSVMParams_t): Double; cdecl;
Procedure  pCvCvSVMParamsSet_degree(const wrapper: PCvCvSVMParams_t; val: Double); cdecl;
Function   pCvCvSVMParamsGet_gamma(const wrapper: PCvCvSVMParams_t): Double; cdecl;
Procedure  pCvCvSVMParamsSet_gamma(const wrapper: PCvCvSVMParams_t; val: Double); cdecl;
Function   pCvCvSVMParamsGet_kernel_type(const wrapper: PCvCvSVMParams_t): Integer; cdecl;
Procedure  pCvCvSVMParamsSet_kernel_type(const wrapper: PCvCvSVMParams_t; val: Integer); cdecl;
Function   pCvCvSVMParamsGet_nu(const wrapper: PCvCvSVMParams_t): Double; cdecl;
Procedure  pCvCvSVMParamsSet_nu(const wrapper: PCvCvSVMParams_t; val: Double); cdecl;
Function   pCvCvSVMParamsGet_p(const wrapper: PCvCvSVMParams_t): Double; cdecl;
Procedure  pCvCvSVMParamsSet_p(const wrapper: PCvCvSVMParams_t; val: Double); cdecl;
Function   pCvCvSVMParamsGet_svm_type(const wrapper: PCvCvSVMParams_t): Integer; cdecl;
Procedure  pCvCvSVMParamsSet_svm_type(const wrapper: PCvCvSVMParams_t; val: Integer); cdecl;
Function   pCvCvSVMParamsGet_term_crit(const wrapper: PCvCvSVMParams_t): PCvCvTermCriteria_t; cdecl;
Procedure  pCvCvSVMParamsSet_term_crit(const wrapper: PCvCvSVMParams_t; val: PCvCvTermCriteria_t); cdecl;
Procedure  pCvCvStatModelload(const wrapper: PCvCvStatModel_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Procedure  pCvCvStatModelsave(const wrapper: PCvCvStatModel_t; filename: PAnsiChar; name: PAnsiChar { default: 0 }); cdecl;
Function   pCvDMatchGet_distance(const wrapper: PCvDMatch_t): Single; cdecl;
Procedure  pCvDMatchSet_distance(const wrapper: PCvDMatch_t; val: Single); cdecl;
Function   pCvDMatchGet_imgIdx(const wrapper: PCvDMatch_t): Integer; cdecl;
Procedure  pCvDMatchSet_imgIdx(const wrapper: PCvDMatch_t; val: Integer); cdecl;
Function   pCvDMatchGet_queryIdx(const wrapper: PCvDMatch_t): Integer; cdecl;
Procedure  pCvDMatchSet_queryIdx(const wrapper: PCvDMatch_t; val: Integer); cdecl;
Function   pCvDMatchGet_trainIdx(const wrapper: PCvDMatch_t): Integer; cdecl;
Procedure  pCvDMatchSet_trainIdx(const wrapper: PCvDMatch_t; val: Integer); cdecl;
Procedure  pCvDescriptorExtractorcompute(const wrapper: PCvDescriptorExtractor_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Function   pCvDescriptorExtractorempty(const wrapper: PCvDescriptorExtractor_t): Boolean; cdecl;
Procedure  pCvDescriptorMatcheradd(const wrapper: PCvDescriptorMatcher_t; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvDescriptorMatcherclear(const wrapper: PCvDescriptorMatcher_t); cdecl;
Function   pCvDescriptorMatcherempty(const wrapper: PCvDescriptorMatcher_t): Boolean; cdecl;
Function   pCvDescriptorMatchergetTrainDescriptors(const wrapper: PCvDescriptorMatcher_t): PCvvector_Mat; cdecl;
Procedure  pCvDescriptorMatcherknnMatch(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvMat_t; trainDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; k: Integer; mask: PCvMat_t { default: Mat() }; compactResult: Boolean { default: false }); cdecl;
Procedure  pCvDescriptorMatcherknnMatch2(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; k: Integer; masks: PCvvector_Mat { default: vector<Mat>() }; compactResult: Boolean { default: false }); cdecl;
Procedure  pCvDescriptorMatchermatch(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvMat_t; trainDescriptors: PCvMat_t; matches: PCvvector_DMatch; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvDescriptorMatchermatch2(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvMat_t; matches: PCvvector_DMatch; masks: PCvvector_Mat { default: vector<Mat>() }); cdecl;
Procedure  pCvDescriptorMatchertrain(const wrapper: PCvDescriptorMatcher_t); cdecl;
Procedure  pCvEMclear(const wrapper: PCvEM_t); cdecl;
Function   pCvEMisTrained(const wrapper: PCvEM_t): Boolean; cdecl;
Function   pCvEMpredict(const wrapper: PCvEM_t; sample: PCvMat_t; probs: PCvMat_t { default: Mat() }): PCvVec2d_t; cdecl;
Function   pCvEMtrain(const wrapper: PCvEM_t; samples: PCvMat_t; logLikelihoods: PCvMat_t { default: Mat() }; labels: PCvMat_t { default: Mat() }; probs: PCvMat_t { default: Mat() }): Boolean; cdecl;
Function   pCvEMtrainE(const wrapper: PCvEM_t; samples: PCvMat_t; means0: PCvMat_t; covs0: PCvMat_t { default: Mat() }; weights0: PCvMat_t { default: Mat() }; logLikelihoods: PCvMat_t { default: Mat() }; labels: PCvMat_t { default: Mat() }; probs: PCvMat_t { default: Mat() }): Boolean; cdecl;
Function   pCvEMtrainM(const wrapper: PCvEM_t; samples: PCvMat_t; probs0: PCvMat_t; logLikelihoods: PCvMat_t { default: Mat() }; labels: PCvMat_t { default: Mat() }; probs: PCvMat_t { default: Mat() }): Boolean; cdecl;
Procedure  pCvFaceRecognizerload(const wrapper: PCvFaceRecognizer_t; filename: PCvString_t); cdecl;
Procedure  pCvFaceRecognizerpredict(const wrapper: PCvFaceRecognizer_t; src: PCvMat_t; _label: Integer; confidence: Double); cdecl;
Procedure  pCvFaceRecognizersave(const wrapper: PCvFaceRecognizer_t; filename: PCvString_t); cdecl;
Procedure  pCvFaceRecognizertrain(const wrapper: PCvFaceRecognizer_t; src: PCvvector_Mat; labels: PCvMat_t); cdecl;
Procedure  pCvFaceRecognizerupdate(const wrapper: PCvFaceRecognizer_t; src: PCvvector_Mat; labels: PCvMat_t); cdecl;
Procedure  pCvFastFeatureDetectordetect(const wrapper: PCvFastFeatureDetector_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvFeature2Dcompute(const wrapper: PCvFeature2D_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Procedure  pCvFeature2Ddetect(const wrapper: PCvFeature2D_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvFeature2DdetectAndCompute(const wrapper: PCvFeature2D_t; image: PCvMat_t; mask: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; useProvidedKeypoints: Boolean { default: false }); cdecl;
Procedure  pCvFeatureDetectordetect(const wrapper: PCvFeatureDetector_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() }); cdecl;
Function   pCvFeatureDetectorempty(const wrapper: PCvFeatureDetector_t): Boolean; cdecl;
Function   pCvFileNodeempty(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisInt(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisMap(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisNamed(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisNone(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisReal(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisSeq(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisString(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodename(const wrapper: PCvFileNode_t): PCvString_t; cdecl;
Function   pCvFileNodegetelem(const wrapper: PCvFileNode_t; nodename: PAnsiChar): PCvFileNode_t; cdecl;
Function   pCvFileNodegetelem2(const wrapper: PCvFileNode_t; i: Integer): PCvFileNode_t; cdecl;
Function   pCvFileNodesize(const wrapper: PCvFileNode_t): Word; cdecl;
Function   pCvFileNodetype(const wrapper: PCvFileNode_t): Integer; cdecl;
Function   pCvFileStoragegetFirstTopLevelNode(const wrapper: PCvFileStorage_t): PCvFileNode_t; cdecl;
Function   pCvFileStorageisOpened(const wrapper: PCvFileStorage_t): Boolean; cdecl;
Function   pCvFileStorageopen(const wrapper: PCvFileStorage_t; filename: PCvString_t; flags: Integer; encoding: PCvString_t { default: string() }): Boolean; cdecl;
Function   pCvFileStoragegetelem(const wrapper: PCvFileStorage_t; nodename: PAnsiChar): PCvFileNode_t; cdecl;
Procedure  pCvFileStoragerelease(const wrapper: PCvFileStorage_t); cdecl;
Function   pCvFileStoragereleaseAndGetString(const wrapper: PCvFileStorage_t): PCvString_t; cdecl;
Function   pCvFileStorageroot(const wrapper: PCvFileStorage_t; streamidx: Integer { default: 0 }): PCvFileNode_t; cdecl;
Procedure  pCvFlannBasedMatcheradd(const wrapper: PCvFlannBasedMatcher_t; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvFlannBasedMatcherclear(const wrapper: PCvFlannBasedMatcher_t); cdecl;
Function   pCvFlannBasedMatcherempty(const wrapper: PCvFlannBasedMatcher_t): Boolean; cdecl;
Function   pCvFlannBasedMatchergetTrainDescriptors(const wrapper: PCvFlannBasedMatcher_t): PCvvector_Mat; cdecl;
Procedure  pCvFlannBasedMatcherknnMatch(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvMat_t; trainDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; k: Integer; mask: PCvMat_t { default: Mat() }; compactResult: Boolean { default: false }); cdecl;
Procedure  pCvFlannBasedMatcherknnMatch2(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; k: Integer; masks: PCvvector_Mat { default: vector<Mat>() }; compactResult: Boolean { default: false }); cdecl;
Procedure  pCvFlannBasedMatchermatch(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvMat_t; trainDescriptors: PCvMat_t; matches: PCvvector_DMatch; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvFlannBasedMatchermatch2(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvMat_t; matches: PCvvector_DMatch; masks: PCvvector_Mat { default: vector<Mat>() }); cdecl;
Procedure  pCvFlannBasedMatchertrain(const wrapper: PCvFlannBasedMatcher_t); cdecl;
Procedure  pCvGFTTDetectordetect(const wrapper: PCvGFTTDetector_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvGridAdaptedFeatureDetectordetect(const wrapper: PCvGridAdaptedFeatureDetector_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() }); cdecl;
Function   pCvHOGDescriptorcheckDetectorSize(const wrapper: PCvHOGDescriptor_t): Boolean; cdecl;
Procedure  pCvHOGDescriptorcompute(const wrapper: PCvHOGDescriptor_t; img: PCvMat_t; descriptors: PCvvector_float; winStride: PCvSize_t { default: Size() }; padding: PCvSize_t { default: Size() }; locations: PCvvector_Point { default: vector<Point>() }); cdecl;
Procedure  pCvHOGDescriptorcomputeGradient(const wrapper: PCvHOGDescriptor_t; img: PCvMat_t; grad: PCvMat_t; angleOfs: PCvMat_t; paddingTL: PCvSize_t { default: Size() }; paddingBR: PCvSize_t { default: Size() }); cdecl;
Procedure  pCvHOGDescriptordetect(const wrapper: PCvHOGDescriptor_t; img: PCvMat_t; foundLocations: PCvvector_Point; weights: PCvvector_double; hitThreshold: Double { default: 0 }; winStride: PCvSize_t { default: Size() }; padding: PCvSize_t { default: Size() }; searchLocations: PCvvector_Point { default: vector<Point>() }); cdecl;
Procedure  pCvHOGDescriptordetectMultiScale(const wrapper: PCvHOGDescriptor_t; img: PCvMat_t; foundLocations: PCvvector_Rect; foundWeights: PCvvector_double; hitThreshold: Double { default: 0 }; winStride: PCvSize_t { default: Size() }; padding: PCvSize_t { default: Size() }; scale: Double { default: 1.05 }; finalThreshold: Double { default: 2.0 }; useMeanshiftGrouping: Boolean { default: false }); cdecl;
Function   pCvHOGDescriptorgetDescriptorSize(const wrapper: PCvHOGDescriptor_t): Word; cdecl;
Function   pCvHOGDescriptorgetWinSigma(const wrapper: PCvHOGDescriptor_t): Double; cdecl;
Function   pCvHOGDescriptorload(const wrapper: PCvHOGDescriptor_t; filename: PCvString_t; objname: PCvString_t { default: String() }): Boolean; cdecl;
Procedure  pCvHOGDescriptorsave(const wrapper: PCvHOGDescriptor_t; filename: PCvString_t; objname: PCvString_t { default: String() }); cdecl;
Procedure  pCvHOGDescriptorsetSVMDetector(const wrapper: PCvHOGDescriptor_t; _svmdetector: PCvMat_t); cdecl;
Function   pCvHOGDescriptorGet_L2HysThreshold(const wrapper: PCvHOGDescriptor_t): Double; cdecl;
Function   pCvHOGDescriptorGet_blockSize(const wrapper: PCvHOGDescriptor_t): PCvSize_t; cdecl;
Function   pCvHOGDescriptorGet_blockStride(const wrapper: PCvHOGDescriptor_t): PCvSize_t; cdecl;
Function   pCvHOGDescriptorGet_cellSize(const wrapper: PCvHOGDescriptor_t): PCvSize_t; cdecl;
Function   pCvHOGDescriptorGet_derivAperture(const wrapper: PCvHOGDescriptor_t): Integer; cdecl;
Function   pCvHOGDescriptorGet_gammaCorrection(const wrapper: PCvHOGDescriptor_t): Boolean; cdecl;
Function   pCvHOGDescriptorGet_histogramNormType(const wrapper: PCvHOGDescriptor_t): Integer; cdecl;
Function   pCvHOGDescriptorGet_nbins(const wrapper: PCvHOGDescriptor_t): Integer; cdecl;
Function   pCvHOGDescriptorGet_nlevels(const wrapper: PCvHOGDescriptor_t): Integer; cdecl;
Function   pCvHOGDescriptorGet_svmDetector(const wrapper: PCvHOGDescriptor_t): PCvvector_float; cdecl;
Function   pCvHOGDescriptorGet_winSigma(const wrapper: PCvHOGDescriptor_t): Double; cdecl;
Function   pCvHOGDescriptorGet_winSize(const wrapper: PCvHOGDescriptor_t): PCvSize_t; cdecl;
Procedure  pCvKDTreebuild(const wrapper: PCvKDTree_t; points: PCvMat_t; copyAndReorderPoints: Boolean { default: false }); cdecl;
Procedure  pCvKDTreebuild2(const wrapper: PCvKDTree_t; points: PCvMat_t; labels: PCvMat_t; copyAndReorderPoints: Boolean { default: false }); cdecl;
Function   pCvKDTreedims(const wrapper: PCvKDTree_t): Integer; cdecl;
Function   pCvKDTreefindNearest(const wrapper: PCvKDTree_t; vec: PCvMat_t; K: Integer; Emax: Integer; neighborsIdx: PCvMat_t; neighbors: PCvMat_t { default: Mat() }; dist: PCvMat_t { default: Mat() }; labels: PCvMat_t { default: Mat() }): Integer; cdecl;
Procedure  pCvKDTreefindOrthoRange(const wrapper: PCvKDTree_t; minBounds: PCvMat_t; maxBounds: PCvMat_t; neighborsIdx: PCvMat_t; neighbors: PCvMat_t { default: Mat() }; labels: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvKDTreegetPoints(const wrapper: PCvKDTree_t; idx: PCvMat_t; pts: PCvMat_t; labels: PCvMat_t { default: Mat() }); cdecl;
Function   pCvKDTreeGet_labels(const wrapper: PCvKDTree_t): PCvvector_int; cdecl;
Function   pCvKDTreeGet_maxDepth(const wrapper: PCvKDTree_t): Integer; cdecl;
Function   pCvKDTreeGet_normType(const wrapper: PCvKDTree_t): Integer; cdecl;
Procedure  pCvKDTreeSet_normType(const wrapper: PCvKDTree_t; val: Integer); cdecl;
Function   pCvKDTreeGet_points(const wrapper: PCvKDTree_t): PCvMat_t; cdecl;
Function   pCvKalmanFiltercorrect(const wrapper: PCvKalmanFilter_t; measurement: PCvMat_t): PCvMat_t; cdecl;
Function   pCvKalmanFilterpredict(const wrapper: PCvKalmanFilter_t; control: PCvMat_t { default: Mat() }): PCvMat_t; cdecl;
Function   pCvKeyPointGet_angle(const wrapper: PCvKeyPoint_t): Single; cdecl;
Procedure  pCvKeyPointSet_angle(const wrapper: PCvKeyPoint_t; val: Single); cdecl;
Function   pCvKeyPointGet_class_id(const wrapper: PCvKeyPoint_t): Integer; cdecl;
Procedure  pCvKeyPointSet_class_id(const wrapper: PCvKeyPoint_t; val: Integer); cdecl;
Function   pCvKeyPointGet_octave(const wrapper: PCvKeyPoint_t): Integer; cdecl;
Procedure  pCvKeyPointSet_octave(const wrapper: PCvKeyPoint_t; val: Integer); cdecl;
Function   pCvKeyPointGet_pt(const wrapper: PCvKeyPoint_t): PCvPoint2f_t; cdecl;
Procedure  pCvKeyPointSet_pt(const wrapper: PCvKeyPoint_t; val: PCvPoint2f_t); cdecl;
Function   pCvKeyPointGet_response(const wrapper: PCvKeyPoint_t): Single; cdecl;
Procedure  pCvKeyPointSet_response(const wrapper: PCvKeyPoint_t; val: Single); cdecl;
Function   pCvKeyPointGet_size(const wrapper: PCvKeyPoint_t): Single; cdecl;
Procedure  pCvKeyPointSet_size(const wrapper: PCvKeyPoint_t; val: Single); cdecl;
Procedure  pCvMSERdetect(const wrapper: PCvMSER_t; image: PCvMat_t; msers: PCvvector_vector_Point; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvORBcompute(const wrapper: PCvORB_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Procedure  pCvORBdetect(const wrapper: PCvORB_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvORBdetectAndCompute(const wrapper: PCvORB_t; image: PCvMat_t; mask: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; useProvidedKeypoints: Boolean { default: false }); cdecl;
Procedure  pCvPyramidAdaptedFeatureDetectordetect(const wrapper: PCvPyramidAdaptedFeatureDetector_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvSIFTcompute(const wrapper: PCvSIFT_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Function   pCvSIFTdescriptorSize(const wrapper: PCvSIFT_t): Integer; cdecl;
Function   pCvSIFTdescriptorType(const wrapper: PCvSIFT_t): Integer; cdecl;
Procedure  pCvSIFTdetect(const wrapper: PCvSIFT_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvSIFTdetectAndCompute(const wrapper: PCvSIFT_t; image: PCvMat_t; mask: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; useProvidedKeypoints: Boolean { default: false }); cdecl;
Procedure  pCvSURFcompute(const wrapper: PCvSURF_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Function   pCvSURFdescriptorSize(const wrapper: PCvSURF_t): Integer; cdecl;
Function   pCvSURFdescriptorType(const wrapper: PCvSURF_t): Integer; cdecl;
Procedure  pCvSURFdetect(const wrapper: PCvSURF_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvSURFdetectAndCompute(const wrapper: PCvSURF_t; image: PCvMat_t; mask: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; useProvidedKeypoints: Boolean { default: false }); cdecl;
Function   pCvSURFGet_extended(const wrapper: PCvSURF_t): Boolean; cdecl;
Procedure  pCvSURFSet_extended(const wrapper: PCvSURF_t; val: Boolean); cdecl;
Function   pCvSURFGet_hessianThreshold(const wrapper: PCvSURF_t): Double; cdecl;
Procedure  pCvSURFSet_hessianThreshold(const wrapper: PCvSURF_t; val: Double); cdecl;
Function   pCvSURFGet_nOctaveLayers(const wrapper: PCvSURF_t): Integer; cdecl;
Procedure  pCvSURFSet_nOctaveLayers(const wrapper: PCvSURF_t; val: Integer); cdecl;
Function   pCvSURFGet_nOctaves(const wrapper: PCvSURF_t): Integer; cdecl;
Procedure  pCvSURFSet_nOctaves(const wrapper: PCvSURF_t; val: Integer); cdecl;
Function   pCvSURFGet_upright(const wrapper: PCvSURF_t): Boolean; cdecl;
Procedure  pCvSURFSet_upright(const wrapper: PCvSURF_t; val: Boolean); cdecl;
Procedure  pCvSimpleBlobDetectordetect(const wrapper: PCvSimpleBlobDetector_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() }); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_blobColor(const wrapper: PCvSimpleBlobDetector_Params_t): Byte; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_blobColor(const wrapper: PCvSimpleBlobDetector_Params_t; val: Byte); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_filterByArea(const wrapper: PCvSimpleBlobDetector_Params_t): Boolean; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_filterByArea(const wrapper: PCvSimpleBlobDetector_Params_t; val: Boolean); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_filterByCircularity(const wrapper: PCvSimpleBlobDetector_Params_t): Boolean; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_filterByCircularity(const wrapper: PCvSimpleBlobDetector_Params_t; val: Boolean); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_filterByColor(const wrapper: PCvSimpleBlobDetector_Params_t): Boolean; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_filterByColor(const wrapper: PCvSimpleBlobDetector_Params_t; val: Boolean); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_filterByConvexity(const wrapper: PCvSimpleBlobDetector_Params_t): Boolean; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_filterByConvexity(const wrapper: PCvSimpleBlobDetector_Params_t; val: Boolean); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_filterByInertia(const wrapper: PCvSimpleBlobDetector_Params_t): Boolean; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_filterByInertia(const wrapper: PCvSimpleBlobDetector_Params_t; val: Boolean); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_maxArea(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_maxArea(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_maxCircularity(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_maxCircularity(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_maxConvexity(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_maxConvexity(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_maxInertiaRatio(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_maxInertiaRatio(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_maxThreshold(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_maxThreshold(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minArea(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minArea(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minCircularity(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minCircularity(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minConvexity(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minConvexity(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minDistBetweenBlobs(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minDistBetweenBlobs(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minInertiaRatio(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minInertiaRatio(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minRepeatability(const wrapper: PCvSimpleBlobDetector_Params_t): Word; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minRepeatability(const wrapper: PCvSimpleBlobDetector_Params_t; val: Word); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minThreshold(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minThreshold(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_thresholdStep(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_thresholdStep(const wrapper: PCvSimpleBlobDetector_Params_t; val: Single); cdecl;
Procedure  pCvStarDetectordetect(const wrapper: PCvStarDetector_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint); cdecl;
Procedure  pCvStereoBMcompute(const wrapper: PCvStereoBM_t; left: PCvMat_t; right: PCvMat_t; disparity: PCvMat_t; disptype: Integer { default: CV_16S }); cdecl;
Procedure  pCvStereoSGBMcompute(const wrapper: PCvStereoSGBM_t; left: PCvMat_t; right: PCvMat_t; disp: PCvMat_t); cdecl;
Function   pCvStereoSGBMGet_P1(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Procedure  pCvStereoSGBMSet_P1(const wrapper: PCvStereoSGBM_t; val: Integer); cdecl;
Function   pCvStereoSGBMGet_P2(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Procedure  pCvStereoSGBMSet_P2(const wrapper: PCvStereoSGBM_t; val: Integer); cdecl;
Function   pCvStereoSGBMGet_SADWindowSize(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Procedure  pCvStereoSGBMSet_SADWindowSize(const wrapper: PCvStereoSGBM_t; val: Integer); cdecl;
Function   pCvStereoSGBMGet_disp12MaxDiff(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Procedure  pCvStereoSGBMSet_disp12MaxDiff(const wrapper: PCvStereoSGBM_t; val: Integer); cdecl;
Function   pCvStereoSGBMGet_fullDP(const wrapper: PCvStereoSGBM_t): Boolean; cdecl;
Procedure  pCvStereoSGBMSet_fullDP(const wrapper: PCvStereoSGBM_t; val: Boolean); cdecl;
Function   pCvStereoSGBMGet_minDisparity(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Procedure  pCvStereoSGBMSet_minDisparity(const wrapper: PCvStereoSGBM_t; val: Integer); cdecl;
Function   pCvStereoSGBMGet_numberOfDisparities(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Procedure  pCvStereoSGBMSet_numberOfDisparities(const wrapper: PCvStereoSGBM_t; val: Integer); cdecl;
Function   pCvStereoSGBMGet_preFilterCap(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Procedure  pCvStereoSGBMSet_preFilterCap(const wrapper: PCvStereoSGBM_t; val: Integer); cdecl;
Function   pCvStereoSGBMGet_speckleRange(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Procedure  pCvStereoSGBMSet_speckleRange(const wrapper: PCvStereoSGBM_t; val: Integer); cdecl;
Function   pCvStereoSGBMGet_speckleWindowSize(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Procedure  pCvStereoSGBMSet_speckleWindowSize(const wrapper: PCvStereoSGBM_t; val: Integer); cdecl;
Function   pCvStereoSGBMGet_uniquenessRatio(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Procedure  pCvStereoSGBMSet_uniquenessRatio(const wrapper: PCvStereoSGBM_t; val: Integer); cdecl;
Procedure  pCvStereoVarcompute(const wrapper: PCvStereoVar_t; left: PCvMat_t; right: PCvMat_t; disp: PCvMat_t); cdecl;
Function   pCvStereoVarGet_cycle(const wrapper: PCvStereoVar_t): Integer; cdecl;
Procedure  pCvStereoVarSet_cycle(const wrapper: PCvStereoVar_t; val: Integer); cdecl;
Function   pCvStereoVarGet_fi(const wrapper: PCvStereoVar_t): Single; cdecl;
Procedure  pCvStereoVarSet_fi(const wrapper: PCvStereoVar_t; val: Single); cdecl;
Function   pCvStereoVarGet_flags(const wrapper: PCvStereoVar_t): Integer; cdecl;
Procedure  pCvStereoVarSet_flags(const wrapper: PCvStereoVar_t; val: Integer); cdecl;
Function   pCvStereoVarGet_lambda(const wrapper: PCvStereoVar_t): Single; cdecl;
Procedure  pCvStereoVarSet_lambda(const wrapper: PCvStereoVar_t; val: Single); cdecl;
Function   pCvStereoVarGet_levels(const wrapper: PCvStereoVar_t): Integer; cdecl;
Procedure  pCvStereoVarSet_levels(const wrapper: PCvStereoVar_t; val: Integer); cdecl;
Function   pCvStereoVarGet_maxDisp(const wrapper: PCvStereoVar_t): Integer; cdecl;
Procedure  pCvStereoVarSet_maxDisp(const wrapper: PCvStereoVar_t; val: Integer); cdecl;
Function   pCvStereoVarGet_minDisp(const wrapper: PCvStereoVar_t): Integer; cdecl;
Procedure  pCvStereoVarSet_minDisp(const wrapper: PCvStereoVar_t; val: Integer); cdecl;
Function   pCvStereoVarGet_nIt(const wrapper: PCvStereoVar_t): Integer; cdecl;
Procedure  pCvStereoVarSet_nIt(const wrapper: PCvStereoVar_t; val: Integer); cdecl;
Function   pCvStereoVarGet_penalization(const wrapper: PCvStereoVar_t): Integer; cdecl;
Procedure  pCvStereoVarSet_penalization(const wrapper: PCvStereoVar_t; val: Integer); cdecl;
Function   pCvStereoVarGet_poly_n(const wrapper: PCvStereoVar_t): Integer; cdecl;
Procedure  pCvStereoVarSet_poly_n(const wrapper: PCvStereoVar_t; val: Integer); cdecl;
Function   pCvStereoVarGet_poly_sigma(const wrapper: PCvStereoVar_t): Double; cdecl;
Procedure  pCvStereoVarSet_poly_sigma(const wrapper: PCvStereoVar_t; val: Double); cdecl;
Function   pCvStereoVarGet_pyrScale(const wrapper: PCvStereoVar_t): Double; cdecl;
Procedure  pCvStereoVarSet_pyrScale(const wrapper: PCvStereoVar_t; val: Double); cdecl;
Function   pCvSubdiv2DedgeDst(const wrapper: PCvSubdiv2D_t; edge: Integer; dstpt: PCvPoint2f_t { default: 0 }): Integer; cdecl;
Function   pCvSubdiv2DedgeOrg(const wrapper: PCvSubdiv2D_t; edge: Integer; orgpt: PCvPoint2f_t { default: 0 }): Integer; cdecl;
Function   pCvSubdiv2DfindNearest(const wrapper: PCvSubdiv2D_t; pt: PCvPoint2f_t; nearestPt: PCvPoint2f_t { default: 0 }): Integer; cdecl;
Function   pCvSubdiv2DgetEdge(const wrapper: PCvSubdiv2D_t; edge: Integer; nextEdgeType: Integer): Integer; cdecl;
Procedure  pCvSubdiv2DgetEdgeList(const wrapper: PCvSubdiv2D_t; edgeList: PCvvector_Vec4f); cdecl;
Procedure  pCvSubdiv2DgetTriangleList(const wrapper: PCvSubdiv2D_t; triangleList: PCvvector_Vec6f); cdecl;
Function   pCvSubdiv2DgetVertex(const wrapper: PCvSubdiv2D_t; vertex: Integer; firstEdge: PInteger { default: 0 }): PCvPoint2f_t; cdecl;
Procedure  pCvSubdiv2DgetVoronoiFacetList(const wrapper: PCvSubdiv2D_t; idx: PCvvector_int; facetList: PCvvector_vector_Point2f; facetCenters: PCvvector_Point2f); cdecl;
Procedure  pCvSubdiv2DinitDelaunay(const wrapper: PCvSubdiv2D_t; rect: PCvRect_t); cdecl;
Function   pCvSubdiv2Dinsert(const wrapper: PCvSubdiv2D_t; pt: PCvPoint2f_t): Integer; cdecl;
Procedure  pCvSubdiv2Dinsert2(const wrapper: PCvSubdiv2D_t; ptvec: PCvvector_Point2f); cdecl;
Function   pCvSubdiv2Dlocate(const wrapper: PCvSubdiv2D_t; pt: PCvPoint2f_t; edge: Integer; vertex: Integer): Integer; cdecl;
Function   pCvSubdiv2DnextEdge(const wrapper: PCvSubdiv2D_t; edge: Integer): Integer; cdecl;
Function   pCvSubdiv2DrotateEdge(const wrapper: PCvSubdiv2D_t; edge: Integer; rotate: Integer): Integer; cdecl;
Function   pCvSubdiv2DsymEdge(const wrapper: PCvSubdiv2D_t; edge: Integer): Integer; cdecl;
Function   pCvVideoCaptureget(const wrapper: PCvVideoCapture_t; propId: Integer): Double; cdecl;
Function   pCvVideoCapturegrab(const wrapper: PCvVideoCapture_t): Boolean; cdecl;
Function   pCvVideoCaptureisOpened(const wrapper: PCvVideoCapture_t): Boolean; cdecl;
Function   pCvVideoCaptureopen(const wrapper: PCvVideoCapture_t; filename: PCvString_t): Boolean; cdecl;
Function   pCvVideoCaptureopen2(const wrapper: PCvVideoCapture_t; device: Integer): Boolean; cdecl;
Function   pCvVideoCaptureread(const wrapper: PCvVideoCapture_t; image: PCvMat_t): Boolean; cdecl;
Procedure  pCvVideoCapturerelease(const wrapper: PCvVideoCapture_t); cdecl;
Function   pCvVideoCaptureretrieve(const wrapper: PCvVideoCapture_t; image: PCvMat_t; channel: Integer { default: 0 }): Boolean; cdecl;
Function   pCvVideoCaptureset(const wrapper: PCvVideoCapture_t; propId: Integer; value: Double): Boolean; cdecl;
Function   pCvVideoWriterisOpened(const wrapper: PCvVideoWriter_t): Boolean; cdecl;
Function   pCvVideoWriteropen(const wrapper: PCvVideoWriter_t; filename: PCvString_t; fourcc: Integer; fps: Double; frameSize: PCvSize_t; isColor: Boolean { default: true }): Boolean; cdecl;
Procedure  pCvVideoWriterrelease(const wrapper: PCvVideoWriter_t); cdecl;
Procedure  pCvVideoWriterwrite(const wrapper: PCvVideoWriter_t; image: PCvMat_t); cdecl;
Procedure  pCvflann_Indexbuild(const wrapper: PCvflann_Index_t; wholefeatures: PCvMat_t; additionalfeatures: PCvMat_t; params: PCvIndexParams_t; distType: Integer { default: cvflann::FLANN_DIST_L2 }); cdecl;
Function   pCvflann_IndexgetAlgorithm(const wrapper: PCvflann_Index_t): Integer; cdecl;
Function   pCvflann_IndexgetDistance(const wrapper: PCvflann_Index_t): Integer; cdecl;
Procedure  pCvflann_IndexknnSearch(const wrapper: PCvflann_Index_t; query: PCvMat_t; indices: PCvMat_t; dists: PCvMat_t; knn: Integer; params: PCvSearchParams_t { default: SearchParams() }); cdecl;
Function   pCvflann_Indexload(const wrapper: PCvflann_Index_t; features: PCvMat_t; filename: PCvString_t): Boolean; cdecl;
Function   pCvflann_IndexradiusSearch(const wrapper: PCvflann_Index_t; query: PCvMat_t; indices: PCvMat_t; dists: PCvMat_t; radius: Double; maxResults: Integer; params: PCvSearchParams_t { default: SearchParams() }): Integer; cdecl;
Procedure  pCvflann_Indexrelease(const wrapper: PCvflann_Index_t); cdecl;
Procedure  pCvflann_Indexsave(const wrapper: PCvflann_Index_t; filename: PCvString_t); cdecl;
Function   pCvAlgorithm__create(name: PCvString_t): PCvPtr_Algorithm; cdecl;
Procedure  pCvAlgorithm_getList(algorithms: PCvvector_string); cdecl;
Function   pCvCamShift(probImage: PCvMat_t; window: PCvRect_t; criteria: PCvTermCriteria_t): PCvRotatedRect_t; cdecl;
Procedure  pCvCanny(image: PCvMat_t; edges: PCvMat_t; threshold1: Double; threshold2: Double; apertureSize: Integer { default: 3 }; L2gradient: Boolean { default: false }); cdecl;
Function   pCvDescriptorExtractor_create(descriptorExtractorType: PCvString_t): PCvPtr_DescriptorExtractor; cdecl;
Function   pCvDescriptorMatcher_create(descriptorMatcherType: PCvString_t): PCvPtr_DescriptorMatcher; cdecl;
Function   pCvFeature2D_create(name: PCvString_t): PCvPtr_Feature2D; cdecl;
Function   pCvFeatureDetector_create(detectorType: PCvString_t): PCvPtr_FeatureDetector; cdecl;
Procedure  pCvGaussianBlur(src: PCvMat_t; dst: PCvMat_t; ksize: PCvSize_t; sigmaX: Double; sigmaY: Double { default: 0 }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Function   pCvHOGDescriptor_getDaimlerPeopleDetector(): PCvvector_float; cdecl;
Function   pCvHOGDescriptor_getDefaultPeopleDetector(): PCvvector_float; cdecl;
Procedure  pCvHoughCircles(image: PCvMat_t; circles: PCvMat_t; method: Integer; dp: Double; minDist: Double; param1: Double { default: 100 }; param2: Double { default: 100 }; minRadius: Integer { default: 0 }; maxRadius: Integer { default: 0 }); cdecl;
Procedure  pCvHoughLines(image: PCvMat_t; lines: PCvMat_t; rho: Double; theta: Double; threshold: Integer; srn: Double { default: 0 }; stn: Double { default: 0 }); cdecl;
Procedure  pCvHoughLinesP(image: PCvMat_t; lines: PCvMat_t; rho: Double; theta: Double; threshold: Integer; minLineLength: Double { default: 0 }; maxLineGap: Double { default: 0 }); cdecl;
Procedure  pCvHuMoments(m: PCvMoments_t; hu: PCvMat_t); cdecl;
Procedure  pCvLUT(src: PCvMat_t; lut: PCvMat_t; dst: PCvMat_t; interpolation: Integer { default: 0 }); cdecl;
Procedure  pCvLaplacian(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; ksize: Integer { default: 1 }; scale: Double { default: 1 }; delta: Double { default: 0 }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Function   pCvMahalanobis(v1: PCvMat_t; v2: PCvMat_t; icovar: PCvMat_t): Double; cdecl;
Procedure  pCvPCABackProject(data: PCvMat_t; mean: PCvMat_t; eigenvectors: PCvMat_t; result: PCvMat_t); cdecl;
Procedure  pCvPCACompute(data: PCvMat_t; mean: PCvMat_t; eigenvectors: PCvMat_t; maxComponents: Integer { default: 0 }); cdecl;
Procedure  pCvPCAComputeVar(data: PCvMat_t; mean: PCvMat_t; eigenvectors: PCvMat_t; retainedVariance: Double); cdecl;
Procedure  pCvPCAProject(data: PCvMat_t; mean: PCvMat_t; eigenvectors: PCvMat_t; result: PCvMat_t); cdecl;
Function   pCvPSNR(src1: PCvMat_t; src2: PCvMat_t): Double; cdecl;
Function   pCvRQDecomp3x3(src: PCvMat_t; mtxR: PCvMat_t; mtxQ: PCvMat_t; Qx: PCvMat_t { default: Mat() }; Qy: PCvMat_t { default: Mat() }; Qz: PCvMat_t { default: Mat() }): PCvVec3d_t; cdecl;
Procedure  pCvRodrigues(src: PCvMat_t; dst: PCvMat_t; jacobian: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvSVBackSubst(w: PCvMat_t; u: PCvMat_t; vt: PCvMat_t; rhs: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvSVDecomp(src: PCvMat_t; w: PCvMat_t; u: PCvMat_t; vt: PCvMat_t; flags: Integer { default: 0 }); cdecl;
Procedure  pCvScharr(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; dx: Integer; dy: Integer; scale: Double { default: 1 }; delta: Double { default: 0 }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvSobel(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; dx: Integer; dy: Integer; ksize: Integer { default: 3 }; scale: Double { default: 1 }; delta: Double { default: 0 }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvabsdiff(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvaccumulate(src: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvaccumulateProduct(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvaccumulateSquare(src: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvaccumulateWeighted(src: PCvMat_t; dst: PCvMat_t; alpha: Double; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvadaptiveBilateralFilter(src: PCvMat_t; dst: PCvMat_t; ksize: PCvSize_t; sigmaSpace: Double; maxSigmaColor: Double { default: 20.0 }; anchor: PCvPoint_t { default: Point(-1, -1) }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvadaptiveThreshold(src: PCvMat_t; dst: PCvMat_t; maxValue: Double; adaptiveMethod: Integer; thresholdType: Integer; blockSize: Integer; C: Double); cdecl;
Procedure  pCvadd(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() }; dtype: Integer { default: -1 }); cdecl;
Procedure  pCvaddWeighted(src1: PCvMat_t; alpha: Double; src2: PCvMat_t; beta: Double; gamma: Double; dst: PCvMat_t; dtype: Integer { default: -1 }); cdecl;
Procedure  pCvapplyColorMap(src: PCvMat_t; dst: PCvMat_t; colormap: Integer); cdecl;
Procedure  pCvapproxPolyDP(curve: PCvMat_t; approxCurve: PCvMat_t; epsilon: Double; closed: Boolean); cdecl;
Function   pCvarcLength(curve: PCvMat_t; closed: Boolean): Double; cdecl;
Procedure  pCvarrowedLine(img: PCvMat_t; pt1: PCvPoint_t; pt2: PCvPoint_t; color: PCvScalar_t; thickness: Integer { default: 1 }; line_type: Integer { default: 8 }; shift: Integer { default: 0 }; tipLength: Double { default: 0.1 }); cdecl;
Procedure  pCvbatchDistance(src1: PCvMat_t; src2: PCvMat_t; dist: PCvMat_t; dtype: Integer; nidx: PCvMat_t; normType: Integer { default: NORM_L2 }; K: Integer { default: 0 }; mask: PCvMat_t { default: Mat() }; update: Integer { default: 0 }; crosscheck: Boolean { default: false }); cdecl;
Procedure  pCvbilateralFilter(src: PCvMat_t; dst: PCvMat_t; d: Integer; sigmaColor: Double; sigmaSpace: Double; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvbitwise_and(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvbitwise_not(src: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvbitwise_or(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvbitwise_xor(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvblur(src: PCvMat_t; dst: PCvMat_t; ksize: PCvSize_t; anchor: PCvPoint_t { default: Point(-1,-1) }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Function   pCvborderInterpolate(p: Integer; len: Integer; borderType: Integer): Integer; cdecl;
Function   pCvboundingRect(points: PCvMat_t): PCvRect_t; cdecl;
Procedure  pCvboxFilter(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; ksize: PCvSize_t; anchor: PCvPoint_t { default: Point(-1,-1) }; normalize: Boolean { default: true }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Function   pCvbuildOpticalFlowPyramid(img: PCvMat_t; pyramid: PCvvector_Mat; winSize: PCvSize_t; maxLevel: Integer; withDerivatives: Boolean { default: true }; pyrBorder: Integer { default: BORDER_REFLECT_101 }; derivBorder: Integer { default: BORDER_CONSTANT }; tryReuseInputImage: Boolean { default: true }): Integer; cdecl;
Procedure  pCvcalcBackProject(images: PCvvector_Mat; channels: PCvvector_int; hist: PCvMat_t; dst: PCvMat_t; ranges: PCvvector_float; scale: Double); cdecl;
Procedure  pCvcalcCovarMatrix(samples: PCvMat_t; covar: PCvMat_t; mean: PCvMat_t; flags: Integer; ctype: Integer { default: CV_64F }); cdecl;
Function   pCvcalcGlobalOrientation(orientation: PCvMat_t; mask: PCvMat_t; mhi: PCvMat_t; timestamp: Double; duration: Double): Double; cdecl;
Procedure  pCvcalcHist(images: PCvvector_Mat; channels: PCvvector_int; mask: PCvMat_t; hist: PCvMat_t; histSize: PCvvector_int; ranges: PCvvector_float; accumulate: Boolean { default: false }); cdecl;
Procedure  pCvcalcMotionGradient(mhi: PCvMat_t; mask: PCvMat_t; orientation: PCvMat_t; delta1: Double; delta2: Double; apertureSize: Integer { default: 3 }); cdecl;
Procedure  pCvcalcOpticalFlowFarneback(prev: PCvMat_t; next: PCvMat_t; flow: PCvMat_t; pyr_scale: Double; levels: Integer; winsize: Integer; iterations: Integer; poly_n: Integer; poly_sigma: Double; flags: Integer); cdecl;
Procedure  pCvcalcOpticalFlowPyrLK(prevImg: PCvMat_t; nextImg: PCvMat_t; prevPts: PCvMat_t; nextPts: PCvMat_t; status: PCvMat_t; err: PCvMat_t; winSize: PCvSize_t { default: Size(21,21) }; maxLevel: Integer { default: 3 }; criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01) }; flags: Integer { default: 0 }; minEigThreshold: Double { default: 1e-4 }); cdecl;
Procedure  pCvcalcOpticalFlowSF(from: PCvMat_t; _to: PCvMat_t; flow: PCvMat_t; layers: Integer; averaging_block_size: Integer; max_flow: Integer); cdecl;
Procedure  pCvcalcOpticalFlowSF2(from: PCvMat_t; _to: PCvMat_t; flow: PCvMat_t; layers: Integer; averaging_block_size: Integer; max_flow: Integer; sigma_dist: Double; sigma_color: Double; postprocess_window: Integer; sigma_dist_fix: Double; sigma_color_fix: Double; occ_thr: Double; upscale_averaging_radius: Integer; upscale_sigma_dist: Double; upscale_sigma_color: Double; speed_up_thr: Double); cdecl;
Function   pCvcalibrateCamera(objectPoints: PCvvector_Mat; imagePoints: PCvvector_Mat; imageSize: PCvSize_t; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; rvecs: PCvvector_Mat; tvecs: PCvvector_Mat; flags: Integer { default: 0 }; criteria: PCvTermCriteria_t { default: TermCriteria( TermCriteria::COUNT+TermCriteria::EPS, 30, DBL_EPSILON) }): Double; cdecl;
Procedure  pCvcalibrationMatrixValues(cameraMatrix: PCvMat_t; imageSize: PCvSize_t; apertureWidth: Double; apertureHeight: Double; fovx: Double; fovy: Double; focalLength: Double; principalPoint: PCvPoint2d_t; aspectRatio: Double); cdecl;
Procedure  pCvcartToPolar(x: PCvMat_t; y: PCvMat_t; magnitude: PCvMat_t; angle: PCvMat_t; angleInDegrees: Boolean { default: false }); cdecl;
Function   pCvchamerMatching(img: PCvMat_t; templ: PCvMat_t; results: PCvvector_vector_Point; cost: PCvvector_float; templScale: Double { default: 1 }; maxMatches: Integer { default: 20 }; minMatchDistance: Double { default: 1.0 }; padX: Integer { default: 3 }; padY: Integer { default: 3 }; scales: Integer { default: 5 }; minScale: Double { default: 0.6 }; maxScale: Double { default: 1.6 }; orientationWeight: Double { default: 0.5 }; truncate: Double { default: 20 }): Integer; cdecl;
Function   pCvcheckHardwareSupport(feature: Integer): Boolean; cdecl;
Function   pCvcheckRange(a: PCvMat_t; quiet: Boolean { default: true }; pos: PCvPoint_t { default: 0 }; minVal: Double { default: -DBL_MAX }; maxVal: Double { default: DBL_MAX }): Boolean; cdecl;
Procedure  pCvcircle(img: PCvMat_t; center: PCvPoint_t; radius: Integer; color: PCvScalar_t; thickness: Integer { default: 1 }; lineType: Integer { default: 8 }; shift: Integer { default: 0 }); cdecl;
Function   pCvclipLine(imgRect: PCvRect_t; pt1: PCvPoint_t; pt2: PCvPoint_t): Boolean; cdecl;
Procedure  pCvcompare(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; cmpop: Integer); cdecl;
Function   pCvcompareHist(H1: PCvMat_t; H2: PCvMat_t; method: Integer): Double; cdecl;
Procedure  pCvcompleteSymm(mtx: PCvMat_t; lowerToUpper: Boolean { default: false }); cdecl;
Procedure  pCvcomposeRT(rvec1: PCvMat_t; tvec1: PCvMat_t; rvec2: PCvMat_t; tvec2: PCvMat_t; rvec3: PCvMat_t; tvec3: PCvMat_t; dr3dr1: PCvMat_t { default: Mat() }; dr3dt1: PCvMat_t { default: Mat() }; dr3dr2: PCvMat_t { default: Mat() }; dr3dt2: PCvMat_t { default: Mat() }; dt3dr1: PCvMat_t { default: Mat() }; dt3dt1: PCvMat_t { default: Mat() }; dt3dr2: PCvMat_t { default: Mat() }; dt3dt2: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvcomputeCorrespondEpilines(points: PCvMat_t; whichImage: Integer; F: PCvMat_t; lines: PCvMat_t); cdecl;
Function   pCvcontourArea(contour: PCvMat_t; oriented: Boolean { default: false }): Double; cdecl;
Procedure  pCvconvertMaps(map1: PCvMat_t; map2: PCvMat_t; dstmap1: PCvMat_t; dstmap2: PCvMat_t; dstmap1type: Integer; nninterpolation: Boolean { default: false }); cdecl;
Procedure  pCvconvertPointsFromHomogeneous(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvconvertPointsToHomogeneous(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvconvertScaleAbs(src: PCvMat_t; dst: PCvMat_t; alpha: Double { default: 1 }; beta: Double { default: 0 }); cdecl;
Procedure  pCvconvexHull(points: PCvMat_t; hull: PCvMat_t; clockwise: Boolean { default: false }; returnPoints: Boolean { default: true }); cdecl;
Procedure  pCvconvexityDefects(contour: PCvMat_t; convexhull: PCvMat_t; convexityDefects: PCvMat_t); cdecl;
Procedure  pCvcopyMakeBorder(src: PCvMat_t; dst: PCvMat_t; top: Integer; bottom: Integer; left: Integer; right: Integer; borderType: Integer; value: PCvScalar_t { default: Scalar() }); cdecl;
Procedure  pCvcornerEigenValsAndVecs(src: PCvMat_t; dst: PCvMat_t; blockSize: Integer; ksize: Integer; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvcornerHarris(src: PCvMat_t; dst: PCvMat_t; blockSize: Integer; ksize: Integer; k: Double; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvcornerMinEigenVal(src: PCvMat_t; dst: PCvMat_t; blockSize: Integer; ksize: Integer { default: 3 }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvcornerSubPix(image: PCvMat_t; corners: PCvMat_t; winSize: PCvSize_t; zeroZone: PCvSize_t; criteria: PCvTermCriteria_t); cdecl;
Procedure  pCvcorrectMatches(F: PCvMat_t; points1: PCvMat_t; points2: PCvMat_t; newPoints1: PCvMat_t; newPoints2: PCvMat_t); cdecl;
Function   pCvcountNonZero(src: PCvMat_t): Integer; cdecl;
Function   pCvcreateCLAHE(clipLimit: Double { default: 40.0 }; tileGridSize: PCvSize_t { default: Size(8, 8) }): PCvPtr_CLAHE; cdecl;
Function   pCvcreateEigenFaceRecognizer(num_components: Integer { default: 0 }; threshold: Double { default: DBL_MAX }): PCvPtr_FaceRecognizer; cdecl;
Function   pCvcreateFisherFaceRecognizer(num_components: Integer { default: 0 }; threshold: Double { default: DBL_MAX }): PCvPtr_FaceRecognizer; cdecl;
Procedure  pCvcreateHanningWindow(dst: PCvMat_t; winSize: PCvSize_t; _type: Integer); cdecl;
Function   pCvcreateLBPHFaceRecognizer(radius: Integer { default: 1 }; neighbors: Integer { default: 8 }; grid_x: Integer { default: 8 }; grid_y: Integer { default: 8 }; threshold: Double { default: DBL_MAX }): PCvPtr_FaceRecognizer; cdecl;
Function   pCvcubeRoot(val: Single): Single; cdecl;
Procedure  pCvcvtColor(src: PCvMat_t; dst: PCvMat_t; code: Integer; dstCn: Integer { default: 0 }); cdecl;
Procedure  pCvdct(src: PCvMat_t; dst: PCvMat_t; flags: Integer { default: 0 }); cdecl;
Procedure  pCvdecomposeProjectionMatrix(projMatrix: PCvMat_t; cameraMatrix: PCvMat_t; rotMatrix: PCvMat_t; transVect: PCvMat_t; rotMatrixX: PCvMat_t { default: Mat() }; rotMatrixY: PCvMat_t { default: Mat() }; rotMatrixZ: PCvMat_t { default: Mat() }; eulerAngles: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvdestroyAllWindows(); cdecl;
Procedure  pCvdestroyWindow(winname: PCvString_t); cdecl;
Function   pCvdeterminant(mtx: PCvMat_t): Double; cdecl;
Procedure  pCvdft(src: PCvMat_t; dst: PCvMat_t; flags: Integer { default: 0 }; nonzeroRows: Integer { default: 0 }); cdecl;
Procedure  pCvdilate(src: PCvMat_t; dst: PCvMat_t; kernel: PCvMat_t; anchor: PCvPoint_t { default: Point(-1,-1) }; iterations: Integer { default: 1 }; borderType: Integer { default: BORDER_CONSTANT }; borderValue: PCvScalar_t { default: morphologyDefaultBorderValue() }); cdecl;
Procedure  pCvdistanceTransform(src: PCvMat_t; dst: PCvMat_t; distanceType: Integer; maskSize: Integer); cdecl;
Procedure  pCvdistanceTransformWithLabels(src: PCvMat_t; dst: PCvMat_t; labels: PCvMat_t; distanceType: Integer; maskSize: Integer; labelType: Integer { default: DIST_LABEL_CCOMP }); cdecl;
Procedure  pCvdivide(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; scale: Double { default: 1 }; dtype: Integer { default: -1 }); cdecl;
Procedure  pCvdivide2(scale: Double; src2: PCvMat_t; dst: PCvMat_t; dtype: Integer { default: -1 }); cdecl;
Procedure  pCvdrawChessboardCorners(image: PCvMat_t; patternSize: PCvSize_t; corners: PCvMat_t; patternWasFound: Boolean); cdecl;
Procedure  pCvdrawContours(image: PCvMat_t; contours: PCvvector_Mat; contourIdx: Integer; color: PCvScalar_t; thickness: Integer { default: 1 }; lineType: Integer { default: 8 }; hierarchy: PCvMat_t { default: Mat() }; maxLevel: Integer { default: INT_MAX }; offset: PCvPoint_t { default: Point() }); cdecl;
Procedure  pCvdrawDataMatrixCodes(image: PCvMat_t; codes: PCvvector_string; corners: PCvMat_t); cdecl;
Procedure  pCvdrawKeypoints(image: PCvMat_t; keypoints: PCvvector_KeyPoint; outImage: PCvMat_t; color: PCvScalar_t { default: Scalar::all(-1) }; flags: Integer { default: DrawMatchesFlags::DEFAULT }); cdecl;
Procedure  pCvdrawMarker(img: PCvMat_t; position: PCvPoint_t; color: PCvScalar_t; markerType: Integer { default: MARKER_CROSS }; markerSize: Integer { default: 20 }; thickness: Integer { default: 1 }; line_type: Integer { default: 8 }); cdecl;
Function   pCveigen(src: PCvMat_t; computeEigenvectors: Boolean; eigenvalues: PCvMat_t; eigenvectors: PCvMat_t): Boolean; cdecl;
Procedure  pCvellipse(img: PCvMat_t; center: PCvPoint_t; axes: PCvSize_t; angle: Double; startAngle: Double; endAngle: Double; color: PCvScalar_t; thickness: Integer { default: 1 }; lineType: Integer { default: 8 }; shift: Integer { default: 0 }); cdecl;
Procedure  pCvellipse2(img: PCvMat_t; box: PCvRotatedRect_t; color: PCvScalar_t; thickness: Integer { default: 1 }; lineType: Integer { default: 8 }); cdecl;
Procedure  pCvellipse2Poly(center: PCvPoint_t; axes: PCvSize_t; angle: Integer; arcStart: Integer; arcEnd: Integer; delta: Integer; pts: PCvvector_Point); cdecl;
Procedure  pCvequalizeHist(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCverode(src: PCvMat_t; dst: PCvMat_t; kernel: PCvMat_t; anchor: PCvPoint_t { default: Point(-1,-1) }; iterations: Integer { default: 1 }; borderType: Integer { default: BORDER_CONSTANT }; borderValue: PCvScalar_t { default: morphologyDefaultBorderValue() }); cdecl;
Function   pCvestimateAffine3D(src: PCvMat_t; dst: PCvMat_t; _out: PCvMat_t; inliers: PCvMat_t; ransacThreshold: Double { default: 3 }; confidence: Double { default: 0.99 }): Integer; cdecl;
Function   pCvestimateRigidTransform(src: PCvMat_t; dst: PCvMat_t; fullAffine: Boolean): PCvMat_t; cdecl;
Procedure  pCvexp(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvextractChannel(src: PCvMat_t; dst: PCvMat_t; coi: Integer); cdecl;
Function   pCvfastAtan2(y: Single; x: Single): Single; cdecl;
Procedure  pCvfastNlMeansDenoising(src: PCvMat_t; dst: PCvMat_t; h: Single { default: 3 }; templateWindowSize: Integer { default: 7 }; searchWindowSize: Integer { default: 21 }); cdecl;
Procedure  pCvfastNlMeansDenoisingColored(src: PCvMat_t; dst: PCvMat_t; h: Single { default: 3 }; hColor: Single { default: 3 }; templateWindowSize: Integer { default: 7 }; searchWindowSize: Integer { default: 21 }); cdecl;
Procedure  pCvfastNlMeansDenoisingColoredMulti(srcImgs: PCvvector_Mat; dst: PCvMat_t; imgToDenoiseIndex: Integer; temporalWindowSize: Integer; h: Single { default: 3 }; hColor: Single { default: 3 }; templateWindowSize: Integer { default: 7 }; searchWindowSize: Integer { default: 21 }); cdecl;
Procedure  pCvfastNlMeansDenoisingMulti(srcImgs: PCvvector_Mat; dst: PCvMat_t; imgToDenoiseIndex: Integer; temporalWindowSize: Integer; h: Single { default: 3 }; templateWindowSize: Integer { default: 7 }; searchWindowSize: Integer { default: 21 }); cdecl;
Procedure  pCvfillConvexPoly(img: PCvMat_t; points: PCvMat_t; color: PCvScalar_t; lineType: Integer { default: 8 }; shift: Integer { default: 0 }); cdecl;
Procedure  pCvfillPoly(img: PCvMat_t; pts: PCvvector_Mat; color: PCvScalar_t; lineType: Integer { default: 8 }; shift: Integer { default: 0 }; offset: PCvPoint_t { default: Point() }); cdecl;
Procedure  pCvfilter2D(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; kernel: PCvMat_t; anchor: PCvPoint_t { default: Point(-1,-1) }; delta: Double { default: 0 }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvfilterSpeckles(img: PCvMat_t; newVal: Double; maxSpeckleSize: Integer; maxDiff: Double; buf: PCvMat_t { default: Mat() }); cdecl;
Function   pCvfindChessboardCorners(image: PCvMat_t; patternSize: PCvSize_t; corners: PCvMat_t; flags: Integer { default: CALIB_CB_ADAPTIVE_THRESH+CALIB_CB_NORMALIZE_IMAGE }): Boolean; cdecl;
Function   pCvfindCirclesGrid(image: PCvMat_t; patternSize: PCvSize_t; centers: PCvMat_t; flags: Integer { default: CALIB_CB_SYMMETRIC_GRID }; blobDetector: PCvPtr_FeatureDetector { default: new SimpleBlobDetector() }): Boolean; cdecl;
Function   pCvfindCirclesGridDefault(image: PCvMat_t; patternSize: PCvSize_t; centers: PCvMat_t; flags: Integer { default: CALIB_CB_SYMMETRIC_GRID }): Boolean; cdecl;
Procedure  pCvfindContours(image: PCvMat_t; contours: PCvvector_Mat; hierarchy: PCvMat_t; mode: Integer; method: Integer; offset: PCvPoint_t { default: Point() }); cdecl;
Procedure  pCvfindDataMatrix(image: PCvMat_t; codes: PCvvector_string; corners: PCvMat_t { default: Mat() }; dmtx: PCvvector_Mat { default: vector_Mat() }); cdecl;
Function   pCvfindFundamentalMat(points1: PCvMat_t; points2: PCvMat_t; method: Integer { default: FM_RANSAC }; param1: Double { default: 3. }; param2: Double { default: 0.99 }; mask: PCvMat_t { default: Mat() }): PCvMat_t; cdecl;
Function   pCvfindHomography(srcPoints: PCvMat_t; dstPoints: PCvMat_t; method: Integer { default: 0 }; ransacReprojThreshold: Double { default: 3 }; mask: PCvMat_t { default: Mat() }): PCvMat_t; cdecl;
Procedure  pCvfindNonZero(src: PCvMat_t; idx: PCvMat_t); cdecl;
Function   pCvfitEllipse(points: PCvMat_t): PCvRotatedRect_t; cdecl;
Procedure  pCvfitLine(points: PCvMat_t; line: PCvMat_t; distType: Integer; param: Double; reps: Double; aeps: Double); cdecl;
Procedure  pCvflip(src: PCvMat_t; dst: PCvMat_t; flipCode: Integer); cdecl;
Function   pCvfloodFill(image: PCvMat_t; mask: PCvMat_t; seedPoint: PCvPoint_t; newVal: PCvScalar_t; rect: PCvRect_t { default: 0 }; loDiff: PCvScalar_t { default: Scalar() }; upDiff: PCvScalar_t { default: Scalar() }; flags: Integer { default: 4 }): Integer; cdecl;
Procedure  pCvgemm(src1: PCvMat_t; src2: PCvMat_t; alpha: Double; src3: PCvMat_t; beta: Double; dst: PCvMat_t; flags: Integer { default: 0 }); cdecl;
Function   pCvgetAffineTransform(src: PCvMat_t; dst: PCvMat_t): PCvMat_t; cdecl;
Function   pCvgetBuildInformation(): PCvString_t; cdecl;
Function   pCvgetCPUTickCount(): Int64; cdecl;
Function   pCvgetDefaultNewCameraMatrix(cameraMatrix: PCvMat_t; imgsize: PCvSize_t { default: Size() }; centerPrincipalPoint: Boolean { default: false }): PCvMat_t; cdecl;
Procedure  pCvgetDerivKernels(kx: PCvMat_t; ky: PCvMat_t; dx: Integer; dy: Integer; ksize: Integer; normalize: Boolean { default: false }; ktype: Integer { default: CV_32F }); cdecl;
Function   pCvgetGaborKernel(ksize: PCvSize_t; sigma: Double; theta: Double; lambd: Double; gamma: Double; psi: Double { default: CV_PI*0.5 }; ktype: Integer { default: CV_64F }): PCvMat_t; cdecl;
Function   pCvgetGaussianKernel(ksize: Integer; sigma: Double; ktype: Integer { default: CV_64F }): PCvMat_t; cdecl;
Function   pCvgetNumThreads(): Integer; cdecl;
Function   pCvgetNumberOfCPUs(): Integer; cdecl;
Function   pCvgetOptimalDFTSize(vecsize: Integer): Integer; cdecl;
Function   pCvgetOptimalNewCameraMatrix(cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; imageSize: PCvSize_t; alpha: Double; newImgSize: PCvSize_t { default: Size() }; validPixROI: PCvRect_t { default: 0 }; centerPrincipalPoint: Boolean { default: false }): PCvMat_t; cdecl;
Function   pCvgetPerspectiveTransform(src: PCvMat_t; dst: PCvMat_t): PCvMat_t; cdecl;
Procedure  pCvgetRectSubPix(image: PCvMat_t; patchSize: PCvSize_t; center: PCvPoint2f_t; patch: PCvMat_t; patchType: Integer { default: -1 }); cdecl;
Function   pCvgetRotationMatrix2D(center: PCvPoint2f_t; angle: Double; scale: Double): PCvMat_t; cdecl;
Function   pCvgetStructuringElement(shape: Integer; ksize: PCvSize_t; anchor: PCvPoint_t { default: Point(-1,-1) }): PCvMat_t; cdecl;
Function   pCvgetTextSize(text: PCvString_t; fontFace: Integer; fontScale: Double; thickness: Integer; baseLine: PInteger): PCvSize_t; cdecl;
Function   pCvgetThreadNum(): Integer; cdecl;
Function   pCvgetTickCount(): Int64; cdecl;
Function   pCvgetTickFrequency(): Double; cdecl;
Function   pCvgetTrackbarPos(trackbarname: PCvString_t; winname: PCvString_t): Integer; cdecl;
Function   pCvgetValidDisparityROI(roi1: PCvRect_t; roi2: PCvRect_t; minDisparity: Integer; numberOfDisparities: Integer; SADWindowSize: Integer): PCvRect_t; cdecl;
Function   pCvgetWindowProperty(winname: PCvString_t; prop_id: Integer): Double; cdecl;
Procedure  pCvgoodFeaturesToTrack(image: PCvMat_t; corners: PCvMat_t; maxCorners: Integer; qualityLevel: Double; minDistance: Double; mask: PCvMat_t { default: Mat() }; blockSize: Integer { default: 3 }; useHarrisDetector: Boolean { default: false }; k: Double { default: 0.04 }); cdecl;
Procedure  pCvgrabCut(img: PCvMat_t; mask: PCvMat_t; rect: PCvRect_t; bgdModel: PCvMat_t; fgdModel: PCvMat_t; iterCount: Integer; mode: Integer { default: GC_EVAL }); cdecl;
Procedure  pCvgroupRectangles(rectList: PCvvector_Rect; weights: PCvvector_int; groupThreshold: Integer; eps: Double { default: 0.2 }); cdecl;
Procedure  pCvhconcat(src: PCvvector_Mat; dst: PCvMat_t); cdecl;
Procedure  pCvidct(src: PCvMat_t; dst: PCvMat_t; flags: Integer { default: 0 }); cdecl;
Procedure  pCvidft(src: PCvMat_t; dst: PCvMat_t; flags: Integer { default: 0 }; nonzeroRows: Integer { default: 0 }); cdecl;
Function   pCvimdecode(buf: PCvMat_t; flags: Integer): PCvMat_t; cdecl;
Function   pCvimencode(ext: PCvString_t; img: PCvMat_t; buf: PCvvector_uchar; params: PCvvector_int { default: vector<int>() }): Boolean; cdecl;
Function   pCvimread(filename: PCvString_t; flags: Integer { default: 1 }): PCvMat_t; cdecl;
Procedure  pCvimshow(winname: PCvString_t; mat: PCvMat_t); cdecl;
Function   pCvimwrite(filename: PCvString_t; img: PCvMat_t; params: PCvvector_int { default: vector<int>() }): Boolean; cdecl;
Procedure  pCvinRange(src: PCvMat_t; lowerb: PCvMat_t; upperb: PCvMat_t; dst: PCvMat_t); cdecl;
Function   pCvinitCameraMatrix2D(objectPoints: PCvvector_Mat; imagePoints: PCvvector_Mat; imageSize: PCvSize_t; aspectRatio: Double { default: 1. }): PCvMat_t; cdecl;
Function   pCvinitModule_nonfree(): Boolean; cdecl;
Procedure  pCvinitUndistortRectifyMap(cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; R: PCvMat_t; newCameraMatrix: PCvMat_t; size: PCvSize_t; m1type: Integer; map1: PCvMat_t; map2: PCvMat_t); cdecl;
Function   pCvinitWideAngleProjMap(cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; imageSize: PCvSize_t; destImageWidth: Integer; m1type: Integer; map1: PCvMat_t; map2: PCvMat_t; projType: Integer { default: PROJ_SPHERICAL_EQRECT }; alpha: Double { default: 0 }): Single; cdecl;
Procedure  pCvinpaint(src: PCvMat_t; inpaintMask: PCvMat_t; dst: PCvMat_t; inpaintRadius: Double; flags: Integer); cdecl;
Procedure  pCvinsertChannel(src: PCvMat_t; dst: PCvMat_t; coi: Integer); cdecl;
Procedure  pCvintegral(src: PCvMat_t; sum: PCvMat_t; sdepth: Integer { default: -1 }); cdecl;
Procedure  pCvintegral2(src: PCvMat_t; sum: PCvMat_t; sqsum: PCvMat_t; sdepth: Integer { default: -1 }); cdecl;
Procedure  pCvintegral3(src: PCvMat_t; sum: PCvMat_t; sqsum: PCvMat_t; tilted: PCvMat_t; sdepth: Integer { default: -1 }); cdecl;
Function   pCvintersectConvexConvex(_p1: PCvMat_t; _p2: PCvMat_t; _p12: PCvMat_t; handleNested: Boolean { default: true }): Single; cdecl;
Function   pCvinvert(src: PCvMat_t; dst: PCvMat_t; flags: Integer { default: DECOMP_LU }): Double; cdecl;
Procedure  pCvinvertAffineTransform(M: PCvMat_t; iM: PCvMat_t); cdecl;
Function   pCvisContourConvex(contour: PCvMat_t): Boolean; cdecl;
Function   pCvkmeans(data: PCvMat_t; K: Integer; bestLabels: PCvMat_t; criteria: PCvTermCriteria_t; attempts: Integer; flags: Integer; centers: PCvMat_t { default: Mat() }): Double; cdecl;
Procedure  pCvline(img: PCvMat_t; pt1: PCvPoint_t; pt2: PCvPoint_t; color: PCvScalar_t; thickness: Integer { default: 1 }; lineType: Integer { default: 8 }; shift: Integer { default: 0 }); cdecl;
Procedure  pCvlog(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvmagnitude(x: PCvMat_t; y: PCvMat_t; magnitude: PCvMat_t); cdecl;
Procedure  pCvmatMulDeriv(A: PCvMat_t; B: PCvMat_t; dABdA: PCvMat_t; dABdB: PCvMat_t); cdecl;
Function   pCvmatchShapes(contour1: PCvMat_t; contour2: PCvMat_t; method: Integer; parameter: Double): Double; cdecl;
Procedure  pCvmatchTemplate(image: PCvMat_t; templ: PCvMat_t; result: PCvMat_t; method: Integer); cdecl;
Procedure  pCvmax(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t); cdecl;
Function   pCvmean(src: PCvMat_t; mask: PCvMat_t { default: Mat() }): PCvScalar_t; cdecl;
Function   pCvmeanShift(probImage: PCvMat_t; window: PCvRect_t; criteria: PCvTermCriteria_t): Integer; cdecl;
Procedure  pCvmeanStdDev(src: PCvMat_t; mean: PCvMat_t; stddev: PCvMat_t; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvmedianBlur(src: PCvMat_t; dst: PCvMat_t; ksize: Integer); cdecl;
Procedure  pCvmerge(mv: PCvvector_Mat; dst: PCvMat_t); cdecl;
Procedure  pCvmin(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t); cdecl;
Function   pCvminAreaRect(points: PCvMat_t): PCvRotatedRect_t; cdecl;
Procedure  pCvminEnclosingCircle(points: PCvMat_t; center: PCvPoint2f_t; radius: Single); cdecl;
Procedure  pCvminMaxLoc(src: PCvMat_t; minVal: PDouble; maxVal: PDouble { default: 0 }; minLoc: PCvPoint_t { default: 0 }; maxLoc: PCvPoint_t { default: 0 }; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvmixChannels(src: PCvvector_Mat; dst: PCvvector_Mat; fromTo: PCvvector_int); cdecl;
Function   pCvmoments(_array: PCvMat_t; binaryImage: Boolean { default: false }): PCvMoments_t; cdecl;
Procedure  pCvmorphologyEx(src: PCvMat_t; dst: PCvMat_t; op: Integer; kernel: PCvMat_t; anchor: PCvPoint_t { default: Point(-1,-1) }; iterations: Integer { default: 1 }; borderType: Integer { default: BORDER_CONSTANT }; borderValue: PCvScalar_t { default: morphologyDefaultBorderValue() }); cdecl;
Procedure  pCvmoveWindow(winname: PCvString_t; x: Integer; y: Integer); cdecl;
Procedure  pCvmulSpectrums(a: PCvMat_t; b: PCvMat_t; c: PCvMat_t; flags: Integer; conjB: Boolean { default: false }); cdecl;
Procedure  pCvmulTransposed(src: PCvMat_t; dst: PCvMat_t; aTa: Boolean; delta: PCvMat_t { default: Mat() }; scale: Double { default: 1 }; dtype: Integer { default: -1 }); cdecl;
Procedure  pCvmultiply(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; scale: Double { default: 1 }; dtype: Integer { default: -1 }); cdecl;
Procedure  pCvnamedWindow(winname: PCvString_t; flags: Integer { default: WINDOW_AUTOSIZE }); cdecl;
Function   pCvnorm(src1: PCvMat_t; normType: Integer { default: NORM_L2 }; mask: PCvMat_t { default: Mat() }): Double; cdecl;
Function   pCvnorm2(src1: PCvMat_t; src2: PCvMat_t; normType: Integer { default: NORM_L2 }; mask: PCvMat_t { default: Mat() }): Double; cdecl;
Procedure  pCvnormalize(src: PCvMat_t; dst: PCvMat_t; alpha: Double { default: 1 }; beta: Double { default: 0 }; norm_type: Integer { default: NORM_L2 }; dtype: Integer { default: -1 }; mask: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvpatchNaNs(a: PCvMat_t; val: Double { default: 0 }); cdecl;
Procedure  pCvperspectiveTransform(src: PCvMat_t; dst: PCvMat_t; m: PCvMat_t); cdecl;
Procedure  pCvphase(x: PCvMat_t; y: PCvMat_t; angle: PCvMat_t; angleInDegrees: Boolean { default: false }); cdecl;
Function   pCvphaseCorrelate(src1: PCvMat_t; src2: PCvMat_t; window: PCvMat_t { default: Mat() }): PCvPoint2d_t; cdecl;
Function   pCvphaseCorrelateRes(src1: PCvMat_t; src2: PCvMat_t; window: PCvMat_t; response: PDouble { default: 0 }): PCvPoint2d_t; cdecl;
Function   pCvpointPolygonTest(contour: PCvMat_t; pt: PCvPoint2f_t; measureDist: Boolean): Double; cdecl;
Procedure  pCvpolarToCart(magnitude: PCvMat_t; angle: PCvMat_t; x: PCvMat_t; y: PCvMat_t; angleInDegrees: Boolean { default: false }); cdecl;
Procedure  pCvpolylines(img: PCvMat_t; pts: PCvvector_Mat; isClosed: Boolean; color: PCvScalar_t; thickness: Integer { default: 1 }; lineType: Integer { default: 8 }; shift: Integer { default: 0 }); cdecl;
Procedure  pCvpow(src: PCvMat_t; power: Double; dst: PCvMat_t); cdecl;
Procedure  pCvpreCornerDetect(src: PCvMat_t; dst: PCvMat_t; ksize: Integer; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvprojectPoints(objectPoints: PCvMat_t; rvec: PCvMat_t; tvec: PCvMat_t; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; imagePoints: PCvMat_t; jacobian: PCvMat_t { default: Mat() }; aspectRatio: Double { default: 0 }); cdecl;
Procedure  pCvputText(img: PCvMat_t; text: PCvString_t; org: PCvPoint_t; fontFace: Integer; fontScale: Double; color: PCvScalar_t; thickness: Integer { default: 1 }; lineType: Integer { default: 8 }; bottomLeftOrigin: Boolean { default: false }); cdecl;
Procedure  pCvpyrDown(src: PCvMat_t; dst: PCvMat_t; dstsize: PCvSize_t { default: Size() }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvpyrMeanShiftFiltering(src: PCvMat_t; dst: PCvMat_t; sp: Double; sr: Double; maxLevel: Integer { default: 1 }; termcrit: PCvTermCriteria_t { default: TermCriteria( TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) }); cdecl;
Procedure  pCvpyrUp(src: PCvMat_t; dst: PCvMat_t; dstsize: PCvSize_t { default: Size() }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvrandShuffle(dst: PCvMat_t; iterFactor: Double { default: 1. }); cdecl;
Procedure  pCvrandn(dst: PCvMat_t; mean: PCvMat_t; stddev: PCvMat_t); cdecl;
Procedure  pCvrandu(dst: PCvMat_t; low: PCvMat_t; high: PCvMat_t); cdecl;
Procedure  pCvrectangle(img: PCvMat_t; pt1: PCvPoint_t; pt2: PCvPoint_t; color: PCvScalar_t; thickness: Integer { default: 1 }; lineType: Integer { default: 8 }; shift: Integer { default: 0 }); cdecl;
Function   pCvrectify3Collinear(cameraMatrix1: PCvMat_t; distCoeffs1: PCvMat_t; cameraMatrix2: PCvMat_t; distCoeffs2: PCvMat_t; cameraMatrix3: PCvMat_t; distCoeffs3: PCvMat_t; imgpt1: PCvvector_Mat; imgpt3: PCvvector_Mat; imageSize: PCvSize_t; R12: PCvMat_t; T12: PCvMat_t; R13: PCvMat_t; T13: PCvMat_t; R1: PCvMat_t; R2: PCvMat_t; R3: PCvMat_t; P1: PCvMat_t; P2: PCvMat_t; P3: PCvMat_t; Q: PCvMat_t; alpha: Double; newImgSize: PCvSize_t; roi1: PCvRect_t; roi2: PCvRect_t; flags: Integer): Single; cdecl;
Procedure  pCvreduce(src: PCvMat_t; dst: PCvMat_t; dim: Integer; rtype: Integer; dtype: Integer { default: -1 }); cdecl;
Procedure  pCvremap(src: PCvMat_t; dst: PCvMat_t; map1: PCvMat_t; map2: PCvMat_t; interpolation: Integer; borderMode: Integer { default: BORDER_CONSTANT }; borderValue: PCvScalar_t { default: Scalar() }); cdecl;
Procedure  pCvrepeat(src: PCvMat_t; ny: Integer; nx: Integer; dst: PCvMat_t); cdecl;
Procedure  pCvreprojectImageTo3D(disparity: PCvMat_t; _3dImage: PCvMat_t; Q: PCvMat_t; handleMissingValues: Boolean { default: false }; ddepth: Integer { default: -1 }); cdecl;
Procedure  pCvresize(src: PCvMat_t; dst: PCvMat_t; dsize: PCvSize_t; fx: Double { default: 0 }; fy: Double { default: 0 }; interpolation: Integer { default: INTER_LINEAR }); cdecl;
Procedure  pCvresizeWindow(winname: PCvString_t; width: Integer; height: Integer); cdecl;
Procedure  pCvscaleAdd(src1: PCvMat_t; alpha: Double; src2: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvsegmentMotion(mhi: PCvMat_t; segmask: PCvMat_t; boundingRects: PCvvector_Rect; timestamp: Double; segThresh: Double); cdecl;
Procedure  pCvsepFilter2D(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; kernelX: PCvMat_t; kernelY: PCvMat_t; anchor: PCvPoint_t { default: Point(-1,-1) }; delta: Double { default: 0 }; borderType: Integer { default: BORDER_DEFAULT }); cdecl;
Procedure  pCvsetIdentity(mtx: PCvMat_t; s: PCvScalar_t { default: Scalar(1) }); cdecl;
Procedure  pCvsetNumThreads(nthreads: Integer); cdecl;
Procedure  pCvsetRNGSeed(seed: Integer); cdecl;
Procedure  pCvsetTrackbarPos(trackbarname: PCvString_t; winname: PCvString_t; pos: Integer); cdecl;
Procedure  pCvsetUseOptimized(onoff: Boolean); cdecl;
Procedure  pCvsetWindowProperty(winname: PCvString_t; prop_id: Integer; prop_value: Double); cdecl;
Function   pCvsolve(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; flags: Integer { default: DECOMP_LU }): Boolean; cdecl;
Function   pCvsolveCubic(coeffs: PCvMat_t; roots: PCvMat_t): Integer; cdecl;
Function   pCvsolvePnP(objectPoints: PCvMat_t; imagePoints: PCvMat_t; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; rvec: PCvMat_t; tvec: PCvMat_t; useExtrinsicGuess: Boolean { default: false }; flags: Integer { default: ITERATIVE }): Boolean; cdecl;
Procedure  pCvsolvePnPRansac(objectPoints: PCvMat_t; imagePoints: PCvMat_t; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; rvec: PCvMat_t; tvec: PCvMat_t; useExtrinsicGuess: Boolean { default: false }; iterationsCount: Integer { default: 100 }; reprojectionError: Single { default: 8.0 }; minInliersCount: Integer { default: 100 }; inliers: PCvMat_t { default: Mat() }; flags: Integer { default: ITERATIVE }); cdecl;
Function   pCvsolvePoly(coeffs: PCvMat_t; roots: PCvMat_t; maxIters: Integer { default: 300 }): Double; cdecl;
Procedure  pCvsort(src: PCvMat_t; dst: PCvMat_t; flags: Integer); cdecl;
Procedure  pCvsortIdx(src: PCvMat_t; dst: PCvMat_t; flags: Integer); cdecl;
Procedure  pCvsplit(m: PCvMat_t; mv: PCvvector_Mat); cdecl;
Procedure  pCvsqrt(src: PCvMat_t; dst: PCvMat_t); cdecl;
Function   pCvstartWindowThread(): Integer; cdecl;
Function   pCvstereoCalibrate(objectPoints: PCvvector_Mat; imagePoints1: PCvvector_Mat; imagePoints2: PCvvector_Mat; cameraMatrix1: PCvMat_t; distCoeffs1: PCvMat_t; cameraMatrix2: PCvMat_t; distCoeffs2: PCvMat_t; imageSize: PCvSize_t; R: PCvMat_t; T: PCvMat_t; E: PCvMat_t; F: PCvMat_t; criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6) }; flags: Integer { default: CALIB_FIX_INTRINSIC }): Double; cdecl;
Procedure  pCvstereoRectify(cameraMatrix1: PCvMat_t; distCoeffs1: PCvMat_t; cameraMatrix2: PCvMat_t; distCoeffs2: PCvMat_t; imageSize: PCvSize_t; R: PCvMat_t; T: PCvMat_t; R1: PCvMat_t; R2: PCvMat_t; P1: PCvMat_t; P2: PCvMat_t; Q: PCvMat_t; flags: Integer { default: CALIB_ZERO_DISPARITY }; alpha: Double { default: -1 }; newImageSize: PCvSize_t { default: Size() }; validPixROI1: PCvRect_t { default: 0 }; validPixROI2: PCvRect_t { default: 0 }); cdecl;
Function   pCvstereoRectifyUncalibrated(points1: PCvMat_t; points2: PCvMat_t; F: PCvMat_t; imgSize: PCvSize_t; H1: PCvMat_t; H2: PCvMat_t; threshold: Double { default: 5 }): Boolean; cdecl;
Procedure  pCvsubtract(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() }; dtype: Integer { default: -1 }); cdecl;
Function   pCvsumElems(src: PCvMat_t): PCvScalar_t; cdecl;
Function   pCvthreshold(src: PCvMat_t; dst: PCvMat_t; thresh: Double; maxval: Double; _type: Integer): Double; cdecl;
Function   pCvtrace(mtx: PCvMat_t): PCvScalar_t; cdecl;
Procedure  pCvtransform(src: PCvMat_t; dst: PCvMat_t; m: PCvMat_t); cdecl;
Procedure  pCvtranspose(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvtriangulatePoints(projMatr1: PCvMat_t; projMatr2: PCvMat_t; projPoints1: PCvMat_t; projPoints2: PCvMat_t; points4D: PCvMat_t); cdecl;
Procedure  pCvundistort(src: PCvMat_t; dst: PCvMat_t; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; newCameraMatrix: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvundistortPoints(src: PCvMat_t; dst: PCvMat_t; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; R: PCvMat_t { default: Mat() }; P: PCvMat_t { default: Mat() }); cdecl;
Procedure  pCvupdateMotionHistory(silhouette: PCvMat_t; mhi: PCvMat_t; timestamp: Double; duration: Double); cdecl;
Function   pCvuseOptimized(): Boolean; cdecl;
Procedure  pCvvalidateDisparity(disparity: PCvMat_t; cost: PCvMat_t; minDisparity: Integer; numberOfDisparities: Integer; disp12MaxDisp: Integer { default: 1 }); cdecl;
Procedure  pCvvconcat(src: PCvvector_Mat; dst: PCvMat_t); cdecl;
Function   pCvwaitKey(delay: Integer { default: 0 }): Integer; cdecl;
Procedure  pCvwarpAffine(src: PCvMat_t; dst: PCvMat_t; M: PCvMat_t; dsize: PCvSize_t; flags: Integer { default: INTER_LINEAR }; borderMode: Integer { default: BORDER_CONSTANT }; borderValue: PCvScalar_t { default: Scalar() }); cdecl;
Procedure  pCvwarpPerspective(src: PCvMat_t; dst: PCvMat_t; M: PCvMat_t; dsize: PCvSize_t; flags: Integer { default: INTER_LINEAR }; borderMode: Integer { default: BORDER_CONSTANT }; borderValue: PCvScalar_t { default: Scalar() }); cdecl;
Procedure  pCvwatershed(image: PCvMat_t; markers: PCvMat_t); cdecl;
